<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ¸©é¦¨åœ£è¯æ ‘ç›¸å†Œ</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; }
        /* èƒŒæ™¯ï¼šæ·±é‚ƒé™è°§çš„å¹³å®‰å¤œ */
        #canvas-container { width: 100%; height: 100%; background: linear-gradient(to bottom, #010a1f, #0a1a3a); }
        #ui-controls {
            position: absolute; bottom: 40px; width: 100%; text-align: center; pointer-events: none; z-index: 100;
        }
        .btn {
            /* ä¿ç•™V6çš„è±ªåæŒ‰é’®æ ·å¼ */
            background: linear-gradient(to bottom, #d60000, #900000);
            border: 3px solid #ffd700; color: #ffd700; padding: 12px 35px; border-radius: 50px;
            font-size: 18px; font-weight: bold; cursor: pointer; pointer-events: auto;
            box-shadow: 0 0 25px rgba(214, 0, 0, 0.6), inset 0 0 10px rgba(255, 215, 0, 0.3); letter-spacing: 2px; text-shadow: 1px 1px 2px #000;
        }
        #image-upload { display: none; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://registry.npmmirror.com/three/0.160.0/files/build/three.module.js",
            "three/addons/": "https://registry.npmmirror.com/three/0.160.0/files/examples/jsm/",
            "gsap": "https://registry.npmmirror.com/gsap/3.12.5/files/index.js"
        }
    }
    </script>
</head>
<body>

<div id="canvas-container"></div>
<div id="ui-controls">
    <input type="file" id="image-upload" multiple accept="image/*">
    <button class="btn" onclick="document.getElementById('image-upload').click()">ğŸ„ ä¸Šä¼ ç…§ç‰‡å¸ƒç½®åœ£è¯æ ‘</button>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import gsap from 'gsap';

    let scene, camera, renderer, controls;
    let treeGroup, photoCards = [];
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let focusedCard = null;
    let ledLights = []; 
    let snowSystem;

    init();

    function init() {
        scene = new THREE.Scene();
        // é€‚ä¸­çš„é›¾æ°”
        scene.fog = new THREE.FogExp2(0x0a1a3a, 0.018);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 10, 30);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 5; controls.maxDistance = 60;
        controls.target.set(0, 7, 0);
        controls.autoRotate = true; controls.autoRotateSpeed = 0.4;
        controls.addEventListener('start', () => { controls.autoRotate = false; });

        // --- ç¯å…‰ ---
        const ambient = new THREE.AmbientLight(0xccccff, 0.3);
        scene.add(ambient);
        const mainLight = new THREE.DirectionalLight(0xffd700, 1.2);
        mainLight.position.set(15, 25, 20);
        scene.add(mainLight);
        // åº•éƒ¨æš–å…‰ç…§äº®ç¤¼ç‰©
        const bottomLight = new THREE.PointLight(0xffaa55, 1.0, 25);
        bottomLight.position.set(0, 1, 0);
        scene.add(bottomLight);

        treeGroup = new THREE.Group();
        scene.add(treeGroup);
        
        createClassicTree(); // å›å½’ç»å…¸æ ‘å½¢
        createGifts(); // ä¿ç•™ç¤¼ç‰©
        createStar(); 
        createOptimizedSnow(); // ä¼˜åŒ–åçš„é›ªèŠ±

        window.addEventListener('resize', onWindowResize);
        renderer.domElement.addEventListener('click', onClick);
        renderer.domElement.addEventListener('touchstart', onClick, { passive: false });
        
        animate();
    }

    // --- 1. ç»å…¸å±‚æ¬¡æ„Ÿæ ‘å½¢ (ä¿®å¤å±‚æ•°è¿‡å¤šé—®é¢˜) ---
    function createClassicTree() {
        // é²œè‰³çš„åœ£è¯ç»¿ï¼Œå¸¦ä¸€ç‚¹åå…‰
        const leafMat = new THREE.MeshStandardMaterial({ 
            color: 0x1a661a, roughness: 0.7, metalness: 0.1, flatShading: true 
        });

        // 16å±‚ç»“æ„ï¼Œå±‚æ¬¡åˆ†æ˜
        const layers = 16;
        for (let i = 0; i < layers; i++) {
            const progress = i / layers;
            const radius = 7 * (1 - progress) + 0.5; // åº•éƒ¨å®½é¡¶éƒ¨å°–
            const y = i * 0.9 + 1.5;
            const height = 1.8;
            
            const geo = new THREE.ConeGeometry(radius, height, 14);
            const mesh = new THREE.Mesh(geo, leafMat);
            mesh.position.y = y;
            mesh.rotation.y = Math.random() * Math.PI;
            // åº•éƒ¨å¶ç‰‡ç¨å¾®èƒ–ä¸€ç‚¹
            mesh.scale.set(1 + progress*0.15, 1, 1 + progress*0.15);
            treeGroup.add(mesh);

            // åœ¨æ¯ä¸€å±‚çš„è¾¹ç¼˜æ·»åŠ å½©ç¯ (ä¿®å¤ç¯å¸¦ä¸å¯è§é—®é¢˜)
            addEdgeLights(y - height/2 + 0.1, radius, i);
        }

        const trunkGeo = new THREE.CylinderGeometry(1.0, 1.5, 4, 10);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4A2F1B });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = -0.5;
        treeGroup.add(trunk);
    }

    // æ·»åŠ è¾¹ç¼˜å½©ç¯
    function addEdgeLights(y, radius, layerIndex) {
        // æ¯å±‚ç¯çš„æ•°é‡éšåŠå¾„å˜åŒ–
        const count = Math.floor(radius * 2.8) + 4;
        const colors = [0xff0000, 0xffd700, 0x33ff33, 0x00aaff, 0xff00ff];

        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2 + layerIndex*0.5; // ç¨å¾®é”™å¼€
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;

            const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
            const bulbGeo = new THREE.SphereGeometry(0.12, 8, 8); // ç¯ç å¤§å°
            const bulbMat = new THREE.MeshBasicMaterial({ color: color }); // è‡ªå‘å…‰
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.set(x, y, z);
            treeGroup.add(bulb);
            
            // åŠ å…¥é—ªçƒåŠ¨ç”»é˜Ÿåˆ—
            ledLights.push({ mesh: bulb, baseColor: color, speed: 1.5 + Math.random()*2, offset: Math.random()*Math.PI*2 });
        }
    }

    // --- 2. ä¼˜åŒ–åçš„é›ªèŠ± (ä¿®å¤é›ªèŠ±å¤ªå¤šé—®é¢˜) ---
    function createOptimizedSnow() {
        const geo = new THREE.BufferGeometry();
        // å‡å°‘åˆ° 400 ä¸ªï¼Œé€‚ä¸­
        const snowCount = 400;
        const pos = []; const rot = [];
        for(let i=0; i<snowCount; i++) {
            pos.push((Math.random()-0.5)*80, Math.random()*60, (Math.random()-0.5)*80);
            rot.push(Math.random() * Math.PI);
        }
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        geo.setAttribute('rotation', new THREE.Float32BufferAttribute(rot, 1));
        
        // ä»£ç ç”Ÿæˆé›ªèŠ±çº¹ç†
        const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
        const ctx = canvas.getContext('2d');
        const g = ctx.createRadialGradient(16,16,0,16,16,16);
        g.addColorStop(0, 'rgba(255,255,255,0.9)');
        g.addColorStop(0.6, 'rgba(255,255,255,0.4)');
        g.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = g; ctx.fillRect(0,0,32,32);
        const snowTex = new THREE.CanvasTexture(canvas);

        const mat = new THREE.PointsMaterial({ 
            map: snowTex, color: 0xffffff, size: 1.2,
            transparent: true, opacity: 0.8, 
            blending: THREE.AdditiveBlending, depthWrite: false 
        });
        snowSystem = new THREE.Points(geo, mat);
        scene.add(snowSystem);
    }

    // --- ç¤¼ç‰©å † (ä¿ç•™è±ªåæ„Ÿ) ---
    function createGifts() {
        const giftColors = [0xd60000, 0x006400, 0xffd700, 0x003399];
        for(let i=0; i<10; i++) {
            const s = 1.2 + Math.random() * 1.5;
            const giftGeo = new THREE.BoxGeometry(s, s, s);
            const color = giftColors[Math.floor(Math.random()*giftColors.length)];
            const giftMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.6 });
            const gift = new THREE.Mesh(giftGeo, giftMat);
            
            const angle = Math.random() * Math.PI * 2;
            const r = 3.5 + Math.random() * 4.5;
            gift.position.set(Math.cos(angle)*r, s/2 - 1.8, Math.sin(angle)*r);
            gift.rotation.set(0, Math.random(), 0);

            // ç®€å•çš„é‡‘è‰²ä¸å¸¦
            const ribbon = new THREE.Mesh(new THREE.BoxGeometry(s*1.05, s*0.1, s*1.05), new THREE.MeshStandardMaterial({color:0xffd700, metalness:0.6}));
            gift.add(ribbon);

            treeGroup.add(gift);
        }
    }

    function createStar() {
        const starGeo = new THREE.IcosahedronGeometry(0.9, 0);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.y = 16.5;
        treeGroup.add(star);
        const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=64;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(32,32,0,32,32,32);
        gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)'); gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient; ctx.fillRect(0,0,64,64);
        const glowTex = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ map: glowTex, color: 0xffd700, transparent: true, blending: THREE.AdditiveBlending });
        const sprite = new THREE.Sprite(spriteMat); sprite.scale.set(8, 8, 1); star.add(sprite);
    }

    document.getElementById('image-upload').addEventListener('change', function(e) {
        const files = e.target.files;
        if (!files.length) return;
        photoCards.forEach(c => treeGroup.remove(c)); photoCards = [];
        const maxFiles = Math.min(files.length, 25);
        const loader = new THREE.TextureLoader();
        for (let i = 0; i < maxFiles; i++) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                loader.load(ev.target.result, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    const aspect = texture.image.width / texture.image.height;
                    const w = 2.8; const h = w / aspect;
                    const photoMat = new THREE.MeshBasicMaterial({ map: texture });
                    const photo = new THREE.Mesh(new THREE.PlaneGeometry(w, h), photoMat);
                    const border = new THREE.Mesh(new THREE.BoxGeometry(w+0.15, h+0.15, 0.05), new THREE.MeshStandardMaterial({color: 0xffd700, metalness: 0.8}));
                    border.position.z = -0.03; photo.add(border);
                    const group = new THREE.Group(); group.add(photo);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const y = 2.5 + Math.random() * 11;
                    const r = 7 * (1 - (y/16)) + 1.5; // é€‚é…æ–°æ ‘å½¢çš„æŒ‚è½½åŠå¾„
                    group.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                    group.lookAt(group.position.x*2, y, group.position.z*2);
                    group.rotateZ((Math.random()-0.5)*0.3);
                    treeGroup.add(group); photoCards.push(group);
                    if(photoCards.length === maxFiles) { controls.autoRotate = false; alert("ğŸ„ ç…§ç‰‡å·²æŒ‚å¥½ï¼ç‚¹å‡»ç…§ç‰‡æŸ¥çœ‹ç»†èŠ‚ï¼"); }
                });
            };
            reader.readAsDataURL(files[i]);
        }
    });

    function onClick(event) {
        if (gsap.isTweening(camera.position)) return;
        event.preventDefault();
        const clientX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
        const clientY = event.changedTouches ? event.changedTouches[0].clientY : event.clientY;
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(photoCards, true);
        if (intersects.length > 0) {
            let target = intersects[0].object;
            while(target.parent !== treeGroup) target = target.parent;
            focusOnCard(target);
        } else if (focusedCard) resetCamera();
    }
    function focusOnCard(card) {
        focusedCard = card; controls.enabled = false;
        const targetPos = new THREE.Vector3(); card.children[0].getWorldPosition(targetPos); 
        const offset = targetPos.clone().normalize().multiplyScalar(9);
        offset.y += 0.5;
        const camPos = targetPos.clone().add(offset);
        gsap.to(camera.position, {x: camPos.x, y: camPos.y, z: camPos.z, duration: 1.2, ease: "power2.out"});
        gsap.to(controls.target, {x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: 1.2, ease: "power2.out", onUpdate: () => controls.update()});
    }
    function resetCamera() {
        focusedCard = null;
        gsap.to(camera.position, {x: 0, y: 10, z: 30, duration: 1.2, ease: "power2.inOut", onComplete: () => controls.enabled = true});
        gsap.to(controls.target, {x: 0, y: 7, z: 0, duration: 1.2, ease: "power2.inOut", onUpdate: () => controls.update()});
    }
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        const time = Date.now() * 0.005;
        ledLights.forEach(l => {
            const intensity = (Math.sin(time * l.speed + l.offset) + 1) / 2;
            l.mesh.material.color.lerpColors(new THREE.Color(0x333333), l.baseColor, intensity * 0.7 + 0.3);
        });
        if (snowSystem) {
            const positions = snowSystem.geometry.attributes.position.array;
            for(let i=1; i<positions.length; i+=3) {
                positions[i] -= 0.1; if(positions[i] < -10) positions[i] = 60; 
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            snowSystem.rotation.y += 0.001;
        }
        renderer.render(scene, camera);
    }
</script>
</body>
</html>