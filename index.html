<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>åœ£è¯æ ‘ä¸“å±ç›¸å†Œ</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; }
        #canvas-container { width: 100%; height: 100%; }
        #ui-controls {
            position: absolute; bottom: 40px; width: 100%; text-align: center; pointer-events: none; z-index: 100;
        }
        .btn {
            background: linear-gradient(to bottom, #d60000, #900000);
            border: 2px solid #ffbf00; color: white; padding: 12px 30px; border-radius: 50px;
            font-size: 16px; font-weight: bold; cursor: pointer; pointer-events: auto;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5); letter-spacing: 1px;
        }
        #image-upload { display: none; }
        #loading-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 14px; display: none;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://registry.npmmirror.com/three/0.160.0/files/build/three.module.js",
            "three/addons/": "https://registry.npmmirror.com/three/0.160.0/files/examples/jsm/",
            "gsap": "https://registry.npmmirror.com/gsap/3.12.5/files/index.js"
        }
    }
    </script>
</head>
<body>

<div id="canvas-container"></div>
<div id="loading-text">æ­£åœ¨è£…é¥°...</div>
<div id="ui-controls">
    <input type="file" id="image-upload" multiple accept="image/*">
    <button class="btn" onclick="document.getElementById('image-upload').click()">ğŸ“· ä¸Šä¼ ç…§ç‰‡æŒ‚ä¸Šæ ‘</button>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import gsap from 'gsap';

    let scene, camera, renderer, controls;
    let treeGroup, photoCards = [];
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let focusedCard = null;
    let lights = [];

    init();

    function init() {
        // 1. åœºæ™¯ä¸èƒŒæ™¯ (æ·±è“æ¸å˜)
        scene = new THREE.Scene();
        const canvas = document.createElement('canvas'); canvas.width = 2; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, 0, 512);
        gradient.addColorStop(0, '#000000'); // é¡¶ç«¯é»‘
        gradient.addColorStop(1, '#0a1a3a'); // åº•ç«¯æ·±è“
        ctx.fillStyle = gradient; ctx.fillRect(0, 0, 2, 512);
        scene.background = new THREE.CanvasTexture(canvas);
        scene.fog = new THREE.FogExp2(0x0a1a3a, 0.02);

        // 2. ç›¸æœº
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 8, 22); // æœ€ä½³è§‚èµè·ç¦»

        // 3. æ¸²æŸ“å™¨ (å¼€å¯ç‰©ç†å…‰ç…§æ¨¡å¼)
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // ä¿è¯æ‰‹æœºä¸Šé«˜æ¸…
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // 4. æ§åˆ¶å™¨
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 5; controls.maxDistance = 40;
        controls.target.set(0, 5, 0);
        controls.autoRotate = true; controls.autoRotateSpeed = 0.5;
        controls.addEventListener('start', () => { controls.autoRotate = false; });

        // 5. ç¯å…‰ (æ°›å›´æ„Ÿå…³é”®)
        const ambient = new THREE.AmbientLight(0xffffff, 0.1); // ç¯å¢ƒå…‰æš—ä¸€ç‚¹
        scene.add(ambient);
        
        // æ ‘é¡¶é‡‘è‰²åœ£å…‰
        const topLight = new THREE.PointLight(0xffd700, 2, 30);
        topLight.position.set(0, 15, 0);
        scene.add(topLight);

        // 6. åœºæ™¯å…ƒç´ 
        treeGroup = new THREE.Group();
        scene.add(treeGroup);
        
        createProceduralTree(); // ç”Ÿæˆç²¾ç»†çš„æ ‘
        createStar(); // æ ‘é¡¶æ˜Ÿ
        createSnow(); // ä¸‹é›ª

        window.addEventListener('resize', onWindowResize);
        renderer.domElement.addEventListener('click', onClick);
        renderer.domElement.addEventListener('touchstart', onClick, { passive: false });
        
        animate();
    }

    // --- æ ¸å¿ƒï¼šä¸ç”¨æ¨¡å‹ï¼Œç”¨ä»£ç ç”Ÿæˆå¥½çœ‹çš„æ ‘ ---
    function createProceduralTree() {
        // æ ‘å¶æè´¨ï¼šæ·±ç»¿ï¼Œç²—ç³™åº¦é«˜ï¼Œä¸åå…‰
        const leafMat = new THREE.MeshStandardMaterial({ 
            color: 0x0f5f2f, 
            roughness: 0.8,
            flatShading: true 
        });

        // å †å  15 å±‚åœ†é”¥ï¼Œåšæˆâ€œå®å¡”çŠ¶â€ï¼Œæ¨¡æ‹Ÿæ¾æ ‘çš„å±‚æ¬¡æ„Ÿ
        const layers = 15;
        for (let i = 0; i < layers; i++) {
            const progress = i / layers; // 0 åˆ° 1
            const radius = 6 * (1 - progress) + 0.5; // åº•éƒ¨å®½ï¼Œé¡¶éƒ¨å°–
            const y = i * 0.8 + 1; // é«˜åº¦é€’å¢
            
            // æ¯ä¸€å±‚æ˜¯ä¸€ä¸ªåœ†é”¥
            const geo = new THREE.ConeGeometry(radius, 1.5, 12);
            const mesh = new THREE.Mesh(geo, leafMat);
            mesh.position.y = y;
            // éšæœºæ—‹è½¬ä¸€ç‚¹è§’åº¦ï¼Œè®©æ ‘çœ‹èµ·æ¥è‡ªç„¶ï¼Œä¸åƒµç¡¬
            mesh.rotation.y = Math.random() * Math.PI;
            mesh.scale.set(1, 1, 1);
            treeGroup.add(mesh);

            // åœ¨æ¯ä¸€å±‚çš„è¾¹ç¼˜æŒ‚å½©ç¯
            if (i % 2 === 0) addDecorations(y - 0.5, radius);
        }

        // æ ‘å¹²
        const trunkGeo = new THREE.CylinderGeometry(0.8, 1.2, 4, 8);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3d2817 });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = -1;
        treeGroup.add(trunk);
    }

    // æ·»åŠ å½©ç¯è£…é¥°
    function addDecorations(y, radius) {
        const count = Math.floor(radius * 3) + 2;
        const colors = [0xff0000, 0xffd700, 0x00ff00, 0x00aaff];

        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;

            const color = colors[Math.floor(Math.random() * colors.length)];
            const bulbGeo = new THREE.SphereGeometry(0.12, 8, 8);
            // è‡ªå‘å…‰æè´¨ï¼Œè®©ç¯æ³¡çœŸçš„äº®èµ·æ¥
            const bulbMat = new THREE.MeshBasicMaterial({ color: color });
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.set(x, y, z);
            treeGroup.add(bulb);

            // è®©ç¯æ³¡é—ªçƒ
            lights.push({ mesh: bulb, offset: Math.random() * 10, speed: 2 + Math.random() });
        }
    }

    // æ ‘é¡¶å¤§æ˜Ÿæ˜Ÿ
    function createStar() {
        const starGeo = new THREE.IcosahedronGeometry(0.8, 0);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.y = 13.5;
        treeGroup.add(star);
        // æ˜Ÿæ˜Ÿå…‰æ™•
        const spriteMat = new THREE.SpriteMaterial({ 
            map: new THREE.TextureLoader().load('https://registry.npmmirror.com/three/0.160.0/files/examples/textures/sprites/glow.png'), 
            color: 0xffd700, transparent: true, blending: THREE.AdditiveBlending 
        });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.scale.set(6, 6, 1);
        star.add(sprite);
    }

    // ä¸‹é›ª
    function createSnow() {
        const geo = new THREE.BufferGeometry();
        const pos = [];
        for(let i=0; i<1000; i++) pos.push((Math.random()-0.5)*60, Math.random()*40, (Math.random()-0.5)*60);
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0.8 });
        const snow = new THREE.Points(geo, mat);
        scene.add(snow);
        
        gsap.to(snow.rotation, {y: Math.PI, duration: 100, repeat:-1, ease:"linear"});
    }

    // --- ç…§ç‰‡å¤„ç†æ ¸å¿ƒï¼šé«˜æ¸… + è‡ªå‘å…‰ ---
    document.getElementById('image-upload').addEventListener('change', function(e) {
        const files = e.target.files;
        if (!files.length) return;
        
        // æ¸…é™¤æ—§ç…§ç‰‡
        photoCards.forEach(c => treeGroup.remove(c)); photoCards = [];
        
        // é™åˆ¶ä¸Šä¼ æ•°é‡ï¼Œé˜²æ­¢å¤ªå¡
        const maxFiles = Math.min(files.length, 20);
        let loaded = 0;
        
        const loader = new THREE.TextureLoader();

        for (let i = 0; i < maxFiles; i++) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                loader.load(ev.target.result, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace; // å…³é”®ï¼šè‰²å½©æ ¡æ­£ï¼Œä¸å‘ç°
                    const aspect = texture.image.width / texture.image.height;
                    const w = 2.5; const h = w / aspect;

                    // 1. ç…§ç‰‡æè´¨ï¼šMeshBasicMaterial (ä¸å—å…‰ç…§å½±å“ï¼Œè‡ªå‘å…‰ï¼Œæœ€äº®æœ€æ¸…æ™°)
                    const photoMat = new THREE.MeshBasicMaterial({ map: texture });
                    const photo = new THREE.Mesh(new THREE.PlaneGeometry(w, h), photoMat);
                    
                    // 2. é‡‘è‰²è¾¹æ¡†
                    const border = new THREE.Mesh(new THREE.BoxGeometry(w+0.1, h+0.1, 0.05), new THREE.MeshStandardMaterial({color: 0xffd700, roughness: 0.3, metalness: 0.8}));
                    border.position.z = -0.03;
                    photo.add(border);

                    // æŒ‚è½½é€»è¾‘
                    const group = new THREE.Group();
                    group.add(photo);
                    
                    // éšæœºæŒ‚åœ¨æ ‘ä¸Š
                    const angle = Math.random() * Math.PI * 2;
                    const y = 2 + Math.random() * 9;
                    const r = 5.5 * (1 - (y/13)) + 1.2; // è´´åˆæ ‘å½¢
                    
                    group.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                    group.lookAt(group.position.x*2, y, group.position.z*2); // é¢å‘å¤–
                    group.rotateZ((Math.random()-0.5)*0.2); // æ­ªä¸€ç‚¹
                    
                    treeGroup.add(group);
                    photoCards.push(group);

                    loaded++;
                    if(loaded === maxFiles) {
                        controls.autoRotate = false;
                        alert("ğŸ‰ ç…§ç‰‡æŒ‚å¥½å•¦ï¼ç‚¹å‡»ç…§ç‰‡å¯ä»¥æ”¾å¤§çœ‹å“¦ï¼");
                    }
                });
            };
            reader.readAsDataURL(files[i]);
        }
    });

    // --- äº¤äº’ï¼šç‚¹å‡»æ”¾å¤§ ---
    function onClick(event) {
        if (gsap.isTweening(camera.position)) return;
        event.preventDefault();
        const clientX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
        const clientY = event.changedTouches ? event.changedTouches[0].clientY : event.clientY;
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(photoCards, true);

        if (intersects.length > 0) {
            let target = intersects[0].object;
            while(target.parent !== treeGroup) target = target.parent;
            focusOnCard(target);
        } else if (focusedCard) {
            resetCamera();
        }
    }

    function focusOnCard(card) {
        focusedCard = card; controls.enabled = false;
        // ç®—å‡ºç…§ç‰‡å‰æ–¹çš„åæ ‡
        const targetPos = new THREE.Vector3();
        card.children[0].getWorldPosition(targetPos); // è·å–ç…§ç‰‡Meshçš„ä¸–ç•Œåæ ‡
        const offset = targetPos.clone().normalize().multiplyScalar(6); // å¾€å¤–å»¶ä¼¸6ä¸ªå•ä½
        const camPos = targetPos.clone().add(offset);

        gsap.to(camera.position, {x: camPos.x, y: camPos.y, z: camPos.z, duration: 1});
        gsap.to(controls.target, {x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: 1, onUpdate: () => controls.update()});
    }

    function resetCamera() {
        focusedCard = null;
        gsap.to(camera.position, {x: 0, y: 8, z: 22, duration: 1, onComplete: () => controls.enabled = true});
        gsap.to(controls.target, {x: 0, y: 5, z: 0, duration: 1, onUpdate: () => controls.update()});
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        
        // å½©ç¯é—ªçƒ
        const time = Date.now() * 0.005;
        lights.forEach(l => {
            l.mesh.material.color.setHSL(Math.sin(time * l.speed + l.offset), 1.0, 0.5);
        });
        
        renderer.render(scene, camera);
    }
</script>
</body>
</html>