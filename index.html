<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ¸©é¦¨åœ£è¯æ ‘ç›¸å†Œ</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; }
        #canvas-container { width: 100%; height: 100%; /* æ¸å˜èƒŒæ™¯ï¼šä»é»‘å¤œåˆ°æ·±è“ */ background: linear-gradient(to bottom, #000000, #0a1a3a); }
        #ui-controls {
            position: absolute; bottom: 40px; width: 100%; text-align: center; pointer-events: none; z-index: 100;
        }
        .btn {
            background: linear-gradient(to bottom, #d60000, #900000);
            border: 2px solid #ffbf00; color: white; padding: 12px 30px; border-radius: 50px;
            font-size: 16px; font-weight: bold; cursor: pointer; pointer-events: auto;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5); letter-spacing: 1px;
        }
        #image-upload { display: none; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://registry.npmmirror.com/three/0.160.0/files/build/three.module.js",
            "three/addons/": "https://registry.npmmirror.com/three/0.160.0/files/examples/jsm/",
            "gsap": "https://registry.npmmirror.com/gsap/3.12.5/files/index.js"
        }
    }
    </script>
</head>
<body>

<div id="canvas-container"></div>
<div id="ui-controls">
    <input type="file" id="image-upload" multiple accept="image/*">
    <button class="btn" onclick="document.getElementById('image-upload').click()">ğŸ“· ä¸Šä¼ ç…§ç‰‡æŒ‚ä¸Šæ ‘</button>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import gsap from 'gsap';

    let scene, camera, renderer, controls;
    let treeGroup, photoCards = [];
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let focusedCard = null;
    let lights = [];
    let snowSystem;

    init();

    function init() {
        scene = new THREE.Scene();
        // å¢åŠ ä¸€ç‚¹ç¯å¢ƒé›¾æ°”ï¼Œè®©è¿œå¤„çš„æ ‘å¶æŸ”å’Œä¸€ç‚¹
        scene.fog = new THREE.FogExp2(0x0a1a3a, 0.015);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        // åˆå§‹è§†è§’ç¨å¾®æ‹‰è¿œä¸€ç‚¹ï¼Œçœ‹å…¨æ™¯æ›´å£®è§‚
        camera.position.set(0, 10, 28);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        // ä½¿ç”¨ç”µå½±çº§è‰²è°ƒæ˜ å°„ï¼Œè®©å…‰æ„Ÿæ›´çœŸå®
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1; 
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 5; controls.maxDistance = 50;
        controls.target.set(0, 6, 0);
        controls.autoRotate = true; controls.autoRotateSpeed = 0.4;
        controls.addEventListener('start', () => { controls.autoRotate = false; });

        // --- ç¯å…‰ç³»ç»Ÿå‡çº§ ---
        // ç¯å¢ƒå…‰ï¼šç¨å¾®è°ƒäº®ä¸€ç‚¹å†·è‰²è°ƒï¼Œè®©æš—éƒ¨ä¸æ­»é»‘
        const ambient = new THREE.AmbientLight(0xccccff, 0.3);
        scene.add(ambient);
        
        // ä¸»å…‰æºï¼šæš–é»„è‰²ï¼Œç…§äº®æ ‘çš„æ­£é¢
        const mainLight = new THREE.DirectionalLight(0xffd700, 1.2);
        mainLight.position.set(10, 20, 15);
        scene.add(mainLight);

        // æ ‘é¡¶åœ£å…‰
        const topLight = new THREE.PointLight(0xffd700, 1.5, 30);
        topLight.position.set(0, 16, 0);
        scene.add(topLight);

        treeGroup = new THREE.Group();
        scene.add(treeGroup);
        
        createProceduralTree(); 
        createStar(); 
        createRealSnow(); // ä½¿ç”¨çœŸå®çš„é›ªèŠ±çº¹ç†

        window.addEventListener('resize', onWindowResize);
        renderer.domElement.addEventListener('click', onClick);
        renderer.domElement.addEventListener('touchstart', onClick, { passive: false });
        
        animate();
    }

    // --- 1. æ ‘çš„é¢œè‰²ä¼˜åŒ– ---
    function createProceduralTree() {
        // ã€æ”¹åŠ¨ç‚¹ã€‘é¢œè‰²æ¢æˆäº†æ›´é²œè‰³çš„åœ£è¯ç»¿ï¼Œé™ä½ç²—ç³™åº¦å¢åŠ åå…‰
        const leafMat = new THREE.MeshStandardMaterial({ 
            color: 0x228B22, // Forest Green
            roughness: 0.6, 
            metalness: 0.1,
            flatShading: true 
        });

        const layers = 15;
        for (let i = 0; i < layers; i++) {
            const progress = i / layers;
            const radius = 6.5 * (1 - progress) + 0.5;
            const y = i * 0.85 + 1;
            
            const geo = new THREE.ConeGeometry(radius, 1.8, 12);
            const mesh = new THREE.Mesh(geo, leafMat);
            mesh.position.y = y;
            mesh.rotation.y = Math.random() * Math.PI;
            // è®©åº•éƒ¨çš„æ ‘å¶ç¨å¾®å®½ä¸€ç‚¹èƒ–ä¸€ç‚¹
            mesh.scale.set(1 + progress*0.1, 1, 1 + progress*0.1);
            treeGroup.add(mesh);

            if (i % 2 === 0) addDecorations(y - 0.6, radius);
        }

        const trunkGeo = new THREE.CylinderGeometry(0.8, 1.2, 4, 8);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3d2817 });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = -1;
        treeGroup.add(trunk);
    }

    function addDecorations(y, radius) {
        const count = Math.floor(radius * 2.5) + 3;
        const colors = [0xff0000, 0xffd700, 0x33ff33, 0x00aaff];

        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2 + Math.random()*0.5;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;

            const color = colors[Math.floor(Math.random() * colors.length)];
            const bulbGeo = new THREE.SphereGeometry(0.14, 8, 8);
            const bulbMat = new THREE.MeshBasicMaterial({ color: color });
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.set(x, y, z);
            treeGroup.add(bulb);
            lights.push({ mesh: bulb, offset: Math.random() * 10, speed: 1.5 + Math.random() });
        }
    }

    function createStar() {
        const starGeo = new THREE.IcosahedronGeometry(0.9, 0);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.y = 14.5;
        treeGroup.add(star);
        // ä½¿ç”¨ Canvas åŠ¨æ€ç”Ÿæˆä¸€ä¸ªå‘å…‰å…‰æ™•è´´å›¾ï¼Œä¸ä¾èµ–å¤–éƒ¨æ–‡ä»¶
        const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=64;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(32,32,0,32,32,32);
        gradient.addColorStop(0, 'rgba(255, 215, 0, 1)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient; ctx.fillRect(0,0,64,64);
        const glowTex = new THREE.CanvasTexture(canvas);

        const spriteMat = new THREE.SpriteMaterial({ 
            map: glowTex, color: 0xffd700, transparent: true, blending: THREE.AdditiveBlending, opacity: 0.8
        });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.scale.set(8, 8, 1);
        star.add(sprite);
    }

    // --- 2. çœŸå®çš„é›ªèŠ±çº¹ç† ---
    function createRealSnow() {
        const geo = new THREE.BufferGeometry();
        const pos = []; const rot = [];
        for(let i=0; i<1200; i++) {
            pos.push((Math.random()-0.5)*70, Math.random()*50, (Math.random()-0.5)*70);
            rot.push(Math.random() * Math.PI * 2); // éšæœºåˆå§‹æ—‹è½¬
        }
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        geo.setAttribute('rotation', new THREE.Float32BufferAttribute(rot, 1));
        
        // åŠ è½½é›ªèŠ±çº¹ç† (ä½¿ç”¨ data URI é¿å…å¤–éƒ¨é“¾æ¥å¤±è´¥ï¼Œè¿™æ˜¯ä¸€ä¸ªç®€å•çš„é›ªèŠ±å›¾æ¡ˆ)
        const snowImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAbFBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8bgI2EAAAAI3RSTlMAAQIDBAUGBwgJCgsMDQ4PEBITFBUWFxgZGhscHR4fICEiI40/VRIAAAC2SURBVDjLvZPBDoMgDIaHlFKlFBAQ9P3f9G607bKJ296ILz/8hIQQ5uVq9swQZ+a2A5fGAnYjDkDrJ3AEqgHagV2gGGgG6gH7gWagL+A80A/YB3QDXQFjQCsQ3yG7QA1QF9gNNAJ9AeOAdkAx0ApY/w40A/2A/UAz0BdwHugH7AN6gWJAF9AL2A00An0B44B2QDHA/f8B/w3+G4wDzUBfwHmgH7AP6Aa6AsYA78APv8UJD4xXJzYAAAAASUVORK5CYII=";
        const snowTex = new THREE.TextureLoader().load(snowImage);

        const mat = new THREE.PointsMaterial({ 
            map: snowTex, color: 0xffffff, size: 1.2, 
            transparent: true, opacity: 0.9, 
            blending: THREE.AdditiveBlending, depthWrite: false 
        });
        snowSystem = new THREE.Points(geo, mat);
        scene.add(snowSystem);
    }

    document.getElementById('image-upload').addEventListener('change', function(e) {
        const files = e.target.files;
        if (!files.length) return;
        photoCards.forEach(c => treeGroup.remove(c)); photoCards = [];
        const maxFiles = Math.min(files.length, 25);
        let loaded = 0;
        const loader = new THREE.TextureLoader();

        for (let i = 0; i < maxFiles; i++) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                loader.load(ev.target.result, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    const aspect = texture.image.width / texture.image.height;
                    const w = 2.8; const h = w / aspect;

                    // è‡ªå‘å…‰ç…§ç‰‡
                    const photoMat = new THREE.MeshBasicMaterial({ map: texture });
                    const photo = new THREE.Mesh(new THREE.PlaneGeometry(w, h), photoMat);
                    // é‡‘è‰²è¾¹æ¡†
                    const border = new THREE.Mesh(new THREE.BoxGeometry(w+0.15, h+0.15, 0.05), new THREE.MeshStandardMaterial({color: 0xffd700, roughness: 0.3, metalness: 0.9}));
                    border.position.z = -0.03;
                    photo.add(border);

                    const group = new THREE.Group();
                    group.add(photo);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const y = 2.5 + Math.random() * 10;
                    const r = 6 * (1 - (y/14)) + 1.5; 
                    
                    group.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                    group.lookAt(group.position.x*2, y, group.position.z*2);
                    group.rotateZ((Math.random()-0.5)*0.4);
                    
                    treeGroup.add(group);
                    photoCards.push(group);

                    loaded++;
                    if(loaded === maxFiles) {
                        controls.autoRotate = false;
                        alert("ğŸ‰ ç…§ç‰‡æŒ‚å¥½å•¦ï¼ç‚¹å‡»ä»»æ„ç…§ç‰‡æ”¾å¤§æŸ¥çœ‹ï¼");
                    }
                });
            };
            reader.readAsDataURL(files[i]);
        }
    });

    // --- 3. ç‚¹å‡»äº¤äº’ä¼˜åŒ– ---
    function onClick(event) {
        if (gsap.isTweening(camera.position)) return;
        event.preventDefault();
        const clientX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
        const clientY = event.changedTouches ? event.changedTouches[0].clientY : event.clientY;
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(photoCards, true);

        if (intersects.length > 0) {
            let target = intersects[0].object;
            while(target.parent !== treeGroup) target = target.parent;
            focusOnCard(target);
        } else if (focusedCard) {
            resetCamera();
        }
    }

    function focusOnCard(card) {
        focusedCard = card; controls.enabled = false;
        const targetPos = new THREE.Vector3();
        card.children[0].getWorldPosition(targetPos); 
        
        // ã€æ”¹åŠ¨ç‚¹ã€‘è°ƒæ•´äº†è§‚å¯Ÿè·ç¦»ï¼Œä»6æ”¹æˆäº†9ï¼Œç¦»å¾—æ›´è¿œä¸€ç‚¹ï¼Œè§†é‡æ›´å¼€é˜”
        const offset = targetPos.clone().normalize().multiplyScalar(9); 
        // ã€æ”¹åŠ¨ç‚¹ã€‘ç›¸æœºç¨å¾®æŠ¬é«˜ä¸€ç‚¹ç‚¹ï¼Œä¿¯è§†è§’åº¦çœ‹ç…§ç‰‡æ›´èˆ’æœ
        offset.y += 0.5; 
        const camPos = targetPos.clone().add(offset);

        gsap.to(camera.position, {x: camPos.x, y: camPos.y, z: camPos.z, duration: 1.2, ease: "power2.out"});
        gsap.to(controls.target, {x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: 1.2, ease: "power2.out", onUpdate: () => controls.update()});
    }

    function resetCamera() {
        focusedCard = null;
        gsap.to(camera.position, {x: 0, y: 10, z: 28, duration: 1.2, ease: "power2.inOut", onComplete: () => controls.enabled = true});
        gsap.to(controls.target, {x: 0, y: 6, z: 0, duration: 1.2, ease: "power2.inOut", onUpdate: () => controls.update()});
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        
        const time = Date.now() * 0.005;
        lights.forEach(l => {
            l.mesh.material.color.setHSL(Math.sin(time * l.speed + l.offset), 1.0, 0.5);
        });

        // é›ªèŠ±ä¸‹è½å’Œæ—‹è½¬åŠ¨ç”»
        if (snowSystem) {
            const positions = snowSystem.geometry.attributes.position.array;
            for(let i=1; i<positions.length; i+=3) {
                positions[i] -= 0.1; 
                if(positions[i] < -10) positions[i] = 40; 
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            snowSystem.rotation.y += 0.001; // æ•´ä½“ç¼“æ…¢æ—‹è½¬
        }
        
        renderer.render(scene, camera);
    }
</script>
</body>
</html>