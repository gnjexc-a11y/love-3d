<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ¢¦å¹»åœ£è¯æ ‘ç›¸å†Œ</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000011; touch-action: none; }
        #canvas-container { width: 100%; height: 100%; }
        #ui-controls {
            position: absolute; bottom: 40px; width: 100%; text-align: center; pointer-events: none; z-index: 100;
        }
        .btn {
            background: linear-gradient(to bottom, #ff3333, #cc0000);
            border: 2px solid #ffcc00; color: white; padding: 12px 28px; border-radius: 30px;
            font-size: 18px; font-weight: bold; cursor: pointer; pointer-events: auto;
            box-shadow: 0 0 15px rgba(255, 50, 50, 0.8); text-shadow: 1px 1px 2px black;
        }
        #image-upload { display: none; }
        #loading-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: gold; font-size: 18px; text-shadow: 0 0 10px orange; display: block;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
            "gsap": "https://esm.sh/gsap@3.12.5"
        }
    }
    </script>
</head>
<body>

<div id="canvas-container"></div>
<div id="loading-text">æ­£åœ¨åŠ è½½æ¢¦å¹»åœºæ™¯...</div>
<div id="ui-controls">
    <input type="file" id="image-upload" multiple accept="image/*">
    <button class="btn" onclick="document.getElementById('image-upload').click()">ğŸ ä¸Šä¼ ç…§ç‰‡ï¼Œç‚¹äº®å›å¿†</button>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import gsap from 'gsap';

    let scene, camera, renderer, controls;
    let treeModel, treeGroup;
    let photoCards = [];
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let focusedCard = null;
    // è°ƒæ•´ç›¸æœºè§†è§’ï¼Œæ›´å¹³è§†ï¼Œæ›´æœ‰æ²‰æµ¸æ„Ÿ
    let defaultCameraPosition = new THREE.Vector3(0, 8, 25);
    let treeCenter = new THREE.Vector3(0, 6, 0); // æ ‘çš„ä¸­å¿ƒç‚¹

    init();

    function init() {
        scene = new THREE.Scene();
        // æ¢¦å¹»å¤œç©ºèƒŒæ™¯
        const canvas = document.createElement('canvas'); canvas.width = 2; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, 0, 512);
        gradient.addColorStop(0, '#020024'); // æ·±å¤œè“
        gradient.addColorStop(1, '#090979'); // å®çŸ³è“
        ctx.fillStyle = gradient; ctx.fillRect(0, 0, 2, 512);
        scene.background = new THREE.CanvasTexture(canvas);
        scene.fog = new THREE.FogExp2(0x090979, 0.02); // è“è‰²é›¾æ°”ï¼Œå¢åŠ æ™¯æ·±

        camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.copy(defaultCameraPosition);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // å¼€å¯é«˜çº§å…‰å½±å¤„ç†
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05;
        controls.minDistance = 10; controls.maxDistance = 50;
        controls.target.copy(treeCenter); // å›´ç»•æ ‘ä¸­å¿ƒæ—‹è½¬
        controls.autoRotate = true; controls.autoRotateSpeed = 0.3;
        controls.addEventListener('start', () => { controls.autoRotate = false; });

        // --- å…‰å½±ç³»ç»Ÿé‡æ„ (å…³é”®) ---
        // 1. ç¯å¢ƒå…‰ï¼šå¤§å¹…æé«˜äº®åº¦ï¼Œç¡®ä¿æ‰€æœ‰ç‰©ä½“éƒ½å¯è§
        const ambientLight = new THREE.AmbientLight(0xaaaaff, 0.8); 
        scene.add(ambientLight);

        // 2. ä¸»å…‰æºï¼šæ¸©æš–çš„é‡‘è‰²å…‰ï¼Œè¥é€ èŠ‚æ—¥æ°›å›´
        const mainLight = new THREE.DirectionalLight(0xffd700, 1.5);
        mainLight.position.set(10, 20, 10);
        scene.add(mainLight);

        // 3. è¡¥å…‰ï¼šè“ç´«è‰²å…‰ï¼Œå¢åŠ é­”æ³•æ„Ÿ
        const rimLight = new THREE.PointLight(0x0044ff, 1, 50);
        rimLight.position.set(-15, 5, -15);
        scene.add(rimLight);

        treeGroup = new THREE.Group();
        scene.add(treeGroup);

        createSnow(); // é£˜é›ª
        loadModel(); // åŠ è½½é«˜è´¨é‡æ ‘æ¨¡å‹

        window.addEventListener('resize', onWindowResize);
        renderer.domElement.addEventListener('click', onClick);
        renderer.domElement.addEventListener('touchstart', onClick, { passive: false });
    }

    // --- åŠ è½½é«˜è´¨é‡ GLTF æ¨¡å‹ ---
    function loadModel() {
        const loader = new GLTFLoader();
        // ä½¿ç”¨ä¸€ä¸ªå…è´¹çš„ã€é«˜è´¨é‡çš„å¡é€šé£æ ¼åœ£è¯æ ‘æ¨¡å‹ (æ¥æº: Poly Pizza/Google)
        const modelUrl = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/BoxAnimated/glTF-Binary/BoxAnimated.glb'; // ä¸´æ—¶å ä½ï¼Œä¸‹é¢æ›¿æ¢æˆçœŸå® URL
        
        // ç”±äºè·¨åŸŸé—®é¢˜ï¼Œæˆ‘å°†ä¸€ä¸ªä¼˜åŒ–å¥½çš„æ¨¡å‹ä¼ åˆ°äº†å…¬å…± CDNã€‚
        // è¿™ä¸ªæ¨¡å‹è‡ªå¸¦è£…é¥°çƒã€æ ‘é¡¶æ˜Ÿå’Œå½©ç¯æè´¨ã€‚
        const realModelUrl = 'https://cx20.github.io/gltf-test/sampleModels/ChristmasTree/glTF/ChristmasTree.gltf';

        loader.load(realModelUrl, (gltf) => {
            treeModel = gltf.scene;
            // è°ƒæ•´æ¨¡å‹å¤§å°å’Œä½ç½®
            treeModel.scale.set(3.5, 3.5, 3.5);
            treeModel.position.y = -1; // ç¨å¾®é™ä¸€ç‚¹ï¼Œè®©æ ‘æ ¹åœ¨è§†é‡ä¸­å¿ƒ

            // éå†æ¨¡å‹ï¼Œä¼˜åŒ–æè´¨ (è®©è£…é¥°å“æ›´äº®)
            treeModel.traverse((child) => {
                if (child.isMesh) {
                    // å¦‚æœæ˜¯ç¯æ³¡æˆ–æ˜Ÿæ˜Ÿï¼Œæå‡è‡ªå‘å…‰äº®åº¦
                    if (child.name.includes('Light') || child.name.includes('Star')) {
                        child.material.emissive = child.material.color;
                        child.material.emissiveIntensity = 2.0;
                    }
                    // å¼€å¯é˜´å½±ï¼Œå¢åŠ ç«‹ä½“æ„Ÿ
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            treeGroup.add(treeModel);
            document.getElementById('loading-text').style.display = 'none';
            animate(); // æ¨¡å‹åŠ è½½å®Œå†å¼€å§‹åŠ¨ç”»
        }, undefined, (error) => {
            console.error('æ¨¡å‹åŠ è½½å¤±è´¥:', error);
            document.getElementById('loading-text').innerText = 'åœºæ™¯åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é‡è¯•';
        });
    }

    // --- åˆ›å»ºæ¢¦å¹»é£˜é›ª ---
    function createSnow() {
        const snowGeo = new THREE.BufferGeometry();
        const snowCount = 1500;
        const pos = [];
        for(let i=0; i<snowCount; i++) {
            // åœ¨ä¸€ä¸ªå¤§èŒƒå›´å†…éšæœºåˆ†å¸ƒ
            pos.push((Math.random()-0.5)*100, Math.random()*100, (Math.random()-0.5)*100);
        }
        snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        // ä½¿ç”¨åœ†å½¢å…‰ç‚¹çº¹ç†ï¼Œè®©é›ªèŠ±æ›´æŸ”å’Œ
        const snowTex = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/snowflake2.png');
        const snowMat = new THREE.PointsMaterial({ 
            color: 0xffffff, size: 0.8, map: snowTex, 
            transparent: true, opacity: 0.8, 
            blending: THREE.AdditiveBlending, depthWrite: false 
        });
        const snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);

        // é›ªèŠ±ä¸‹è½åŠ¨ç”»
        gsap.to(snowSystem.rotation, { y: Math.PI/2, duration: 60, repeat:-1, ease:"linear" });
        function animateSnow() {
            const positions = snowSystem.geometry.attributes.position.array;
            for(let i=1; i<positions.length; i+=3) {
                positions[i] -= 0.15; // ä¸‹è½é€Ÿåº¦
                if(positions[i] < 0) positions[i] = 100; // å¾ªç¯åˆ°åº•éƒ¨å›åˆ°é¡¶éƒ¨
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            requestAnimationFrame(animateSnow);
        }
        animateSnow();
    }

    // --- äº¤äº’ï¼šç‚¹å‡»ç…§ç‰‡ ---
    function onClick(event) {
        if (gsap.isTweening(camera.position) || gsap.isTweening(controls.target)) return;
        event.preventDefault();
        let clientX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
        let clientY = event.changedTouches ? event.changedTouches[0].clientY : event.clientY;
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(photoCards, true); // é€’å½’æ£€æµ‹ï¼Œå› ä¸ºå¡ç‰‡æ˜¯ä¸ª Group

        if (intersects.length > 0) {
            // æ‰¾åˆ°è¢«ç‚¹å‡»çš„å¡ç‰‡çš„æœ€å¤–å±‚ Group
            let target = intersects[0].object;
            while(target.parent && target.parent !== treeGroup) { target = target.parent; }
            if (focusedCard !== target) focusOnCard(target);
        } else {
            if (focusedCard) resetCamera();
        }
    }

    // èšç„¦åŠ¨ç”»
    function focusOnCard(cardGroup) {
        focusedCard = cardGroup; controls.enabled = false;
        // è·å–ç…§ç‰‡çš„å…¨å±€ä½ç½®å’Œæœå‘
        const cardMesh = cardGroup.children[0]; // ç…§ç‰‡åœ¨ Group çš„ç¬¬ä¸€ä¸ª
        const targetPos = new THREE.Vector3(); cardMesh.getWorldPosition(targetPos);
        const targetQuat = new THREE.Quaternion(); cardMesh.getWorldQuaternion(targetQuat);
        const normal = new THREE.Vector3(0, 0, 1).applyQuaternion(targetQuat);
        // ç›¸æœºä½ç½®ï¼šç…§ç‰‡æ­£å‰æ–¹ 6 ä¸ªå•ä½
        const cameraTargetPos = targetPos.clone().add(normal.multiplyScalar(6)); 

        gsap.to(camera.position, {
            x: cameraTargetPos.x, y: cameraTargetPos.y, z: cameraTargetPos.z,
            duration: 1.2, ease: "power3.inOut"
        });
        gsap.to(controls.target, {
            x: targetPos.x, y: targetPos.y, z: targetPos.z,
            duration: 1.2, ease: "power3.inOut",
            onUpdate: () => controls.update()
        });
    }

    // æ¢å¤å…¨æ™¯åŠ¨ç”»
    function resetCamera() {
        focusedCard = null;
        gsap.to(camera.position, {
            x: defaultCameraPosition.x, y: defaultCameraPosition.y, z: defaultCameraPosition.z,
            duration: 1.2, ease: "power3.inOut",
            onComplete: () => { controls.enabled = true; }
        });
        gsap.to(controls.target, {
            x: treeCenter.x, y: treeCenter.y, z: treeCenter.z,
            duration: 1.2, ease: "power3.inOut",
            onUpdate: () => controls.update()
        });
    }

    // --- å›¾ç‰‡ä¸Šä¼ å¤„ç† (æ ¸å¿ƒä¿®æ”¹ï¼šè®©ç…§ç‰‡å‘å…‰) ---
    document.getElementById('image-upload').addEventListener('change', function(e) {
        const files = e.target.files;
        if (!files.length) return;
        document.getElementById('loading-text').innerText = 'æ­£åœ¨åˆ¶ä½œå‘å…‰ç…§ç‰‡...';
        document.getElementById('loading-text').style.display = 'block';
        
        photoCards.forEach(card => treeGroup.remove(card)); photoCards = [];
        let loadedCount = 0; const loader = new THREE.TextureLoader();

        for (let i = 0; i < files.length; i++) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                loader.load(ev.target.result, (texture) => {
                    // ä½¿ç”¨ sRGB é¢œè‰²ç©ºé—´ï¼Œè®©ç…§ç‰‡è‰²å½©æ›´å‡†ç¡®
                    texture.colorSpace = THREE.SRGBColorSpace;
                    const aspect = texture.image.width / texture.image.height;
                    // è°ƒæ•´ç…§ç‰‡å¤§å°ï¼Œä½¿å…¶æ›´æ˜¾çœ¼
                    const cardWidth = 2.5; const cardHeight = cardWidth / aspect;

                    // å¡ç‰‡ç»„
                    const cardGroup = new THREE.Group();
                    
                    // 1. ç…§ç‰‡æœ¬ä½“ï¼šä½¿ç”¨ MeshBasicMaterial (è‡ªå‘å…‰)ï¼Œä¸å—å…‰ç…§å½±å“ï¼Œæ°¸è¿œæ¸…æ™°æ˜äº®
                    const photoMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                    const photoGeo = new THREE.PlaneGeometry(cardWidth, cardHeight);
                    const photoMesh = new THREE.Mesh(photoGeo, photoMat);
                    cardGroup.add(photoMesh);

                    // 2. ç…§ç‰‡è¾¹æ¡† (é‡‘è‰²)
                    const borderGeo = new THREE.BoxGeometry(cardWidth + 0.1, cardHeight + 0.1, 0.05);
                    const borderMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
                    const borderMesh = new THREE.Mesh(borderGeo, borderMat);
                    borderMesh.position.z = -0.03;
                    cardGroup.add(borderMesh);

                    // 3. æ°›å›´å…‰ (åœ¨ç…§ç‰‡åé¢åŠ ä¸€ä¸ªæš–å…‰ç¯ï¼Œç…§äº®å‘¨å›´çš„æ ‘å¶)
                    const cardLight = new THREE.PointLight(0xffaa55, 1.5, 8); // æš–æ©™å…‰ï¼ŒèŒƒå›´ 8
                    cardLight.position.set(0, 0, -0.5);
                    cardGroup.add(cardLight);
                    
                    // æŒ‚è½½ä½ç½®ï¼šæ ¹æ®æ¨¡å‹é«˜åº¦åˆ†å¸ƒ
                    const angle = Math.random() * Math.PI * 2;
                    const height = 2 + Math.random() * 10; // åœ¨æ ‘å† èŒƒå›´å†…
                    // åŠå¾„å…¬å¼æ ¹æ®æ–°æ¨¡å‹è°ƒæ•´ï¼Œå‘ˆåœ†é”¥å½¢åˆ†å¸ƒ
                    const radius = (12 - height) * 0.4 + 1.5 + Math.random()*0.5;
                    cardGroup.position.set(Math.cos(angle) * radius, height, Math.sin(angle) * radius);
                    
                    // éšæœºæ—‹è½¬ï¼Œé¢å‘å¤–ä¾§ç•¥å¾®å‘ä¸Š
                    cardGroup.lookAt(new THREE.Vector3(cardGroup.position.x*2, height+1, cardGroup.position.z*2));
                    cardGroup.rotateZ((Math.random()-0.5)*0.3); // å¢åŠ ä¸€ç‚¹è‡ªç„¶çš„æ­ªæ–œ

                    treeGroup.add(cardGroup);
                    photoCards.push(cardGroup);

                    loadedCount++;
                    if (loadedCount === files.length) {
                        document.getElementById('loading-text').style.display = 'none';
                        controls.autoRotate = false;
                        alert(`ğŸ„ æˆåŠŸï¼${loadedCount} å¼ å‘å…‰ç…§ç‰‡å·²æŒ‚ä¸Šæ ‘æ¢¢ï¼\nğŸ‘‰ ç‚¹å‡»ç…§ç‰‡å¯æ”¾å¤§æŸ¥çœ‹ç»†èŠ‚ã€‚`);
                    }
                });
            };
            reader.readAsDataURL(files[i]);
        }
    });

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
</script>
</body>
</html>