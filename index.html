<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ä¸“å±åœ£è¯æ ‘ç›¸å†Œ</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; }
        #canvas-container { width: 100%; height: 100%; }
        /* UI æŒ‰é’®æ ·å¼ */
        #ui-controls {
            position: absolute; bottom: 30px; width: 100%; text-align: center; pointer-events: none; z-index: 100;
        }
        .btn {
            background: rgba(200, 0, 0, 0.7); /* åœ£è¯çº¢ */
            border: 2px solid gold; color: white; padding: 10px 24px; border-radius: 30px;
            font-size: 16px; font-weight: bold; cursor: pointer; pointer-events: auto;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3); text-shadow: 1px 1px 2px black;
        }
        #image-upload { display: none; }
        #loading-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: gold; font-size: 16px; text-shadow: 0 0 10px red; display: none;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
            "gsap": "https://esm.sh/gsap@3.12.5"
        }
    }
    </script>
</head>
<body>

<div id="canvas-container"></div>
<div id="loading-text">æ­£åœ¨è£…é¥°åœ£è¯æ ‘...</div>
<div id="ui-controls">
    <input type="file" id="image-upload" multiple accept="image/*">
    <button class="btn" onclick="document.getElementById('image-upload').click()">ğŸ ä¸Šä¼ ç…§ç‰‡æŒ‚ä¸Šæ ‘</button>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import gsap from 'gsap';

    let scene, camera, renderer, controls;
    let treeGroup, photoCards = [], lights = [];
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let focusedCard = null; // å½“å‰èšç„¦çš„ç…§ç‰‡å¡ç‰‡
    let defaultCameraPosition = new THREE.Vector3(0, 15, 40);

    init();
    animate();

    function init() {
        // 1. åœºæ™¯ä¸èƒŒæ™¯
        scene = new THREE.Scene();
        // æ·±è“è‰²æ¸å˜å¤œç©ºèƒŒæ™¯
        const canvas = document.createElement('canvas'); canvas.width = 2; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, 0, 512);
        gradient.addColorStop(0, '#000022'); // å¤œç©ºæ·±è“
        gradient.addColorStop(1, '#001133'); // åœ°å¹³çº¿è“
        ctx.fillStyle = gradient; ctx.fillRect(0, 0, 2, 512);
        scene.background = new THREE.CanvasTexture(canvas);
        scene.fog = new THREE.FogExp2(0x001133, 0.015); // å¢åŠ é›¾æ°”è¥é€ æ°›å›´

        // 2. ç›¸æœºä¸æ¸²æŸ“å™¨
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.copy(defaultCameraPosition);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // å¼€å¯é˜´å½±
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // 3. æ§åˆ¶å™¨ (å…¨æ™¯æ¨¡å¼)
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20; controls.maxDistance = 80;
        controls.maxPolarAngle = Math.PI / 2 + 0.1; // é™åˆ¶ä¸èƒ½é’»åˆ°åœ°åº•
        controls.autoRotate = true; controls.autoRotateSpeed = 0.5; // ç¼“æ…¢è‡ªåŠ¨æ—‹è½¬
        controls.addEventListener('start', () => { controls.autoRotate = false; });

        // 4. ç¯å…‰ç³»ç»Ÿ
        const ambientLight = new THREE.AmbientLight(0x333333); // å¾®å¼±ç¯å¢ƒå…‰
        scene.add(ambientLight);

        // ä¸»å…‰æºï¼šæ¸©æš–çš„é»„è‰²å…‰ï¼Œç…§äº®åœ£è¯æ ‘
        const mainLight = new THREE.PointLight(0xffcc99, 2, 100);
        mainLight.position.set(10, 20, 20);
        mainLight.castShadow = true;
        scene.add(mainLight);

        // 5. åˆ›å»ºåœºæ™¯å…ƒç´ 
        createSnow();
        createFloor();
        createTree(); // åˆ›å»ºç¨‹åºåŒ–åœ£è¯æ ‘
        createStar(); // æ ‘é¡¶æ˜Ÿ

        // 6. äº‹ä»¶ç›‘å¬
        window.addEventListener('resize', onWindowResize);
        // ç‚¹å‡»äº‹ä»¶ï¼šç”¨äºæŸ¥çœ‹ç…§ç‰‡
        renderer.domElement.addEventListener('click', onClick);
        renderer.domElement.addEventListener('touchstart', onClick, { passive: false });
    }

    // --- æ ¸å¿ƒï¼šç¨‹åºåŒ–ç”Ÿæˆåœ£è¯æ ‘ ---
    function createTree() {
        treeGroup = new THREE.Group();
        scene.add(treeGroup);

        // æ ‘å¹²
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4d2926, roughness: 1.0 });
        const trunkGeo = new THREE.CylinderGeometry(0.5, 1.5, 5, 8);
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 2.5; trunk.castShadow = true; trunk.receiveShadow = true;
        treeGroup.add(trunk);

        // æ ‘å¶ (å¤šå±‚åœ†é”¥ä½“)
        const leafMat = new THREE.MeshStandardMaterial({ color: 0x005522, roughness: 0.8, flatShading: true });
        const layers = 5;
        for (let i = 0; i < layers; i++) {
            const radius = 8 - i * 1.5; // åŠå¾„é€’å‡
            const height = 4 + i * 0.5; // é«˜åº¦é€’å¢
            const yPos = 5 + i * 3;
            const coneGeo = new THREE.ConeGeometry(radius, height, 16);
            const cone = new THREE.Mesh(coneGeo, leafMat);
            cone.position.y = yPos;
            cone.castShadow = true; cone.receiveShadow = true;
            treeGroup.add(cone);

            // åœ¨æ¯å±‚æ ‘å¶è¾¹ç¼˜æ·»åŠ å½©ç¯
            addLightsToLayer(radius, yPos - height/2 + 0.2, 12 - i);
        }
    }

    // æ·»åŠ å½©ç¯
    function addLightsToLayer(radius, yPos, count) {
        const colors = [0xff0000, 0x00ff00, 0xffff00, 0x0000ff];
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            const color = colors[Math.floor(Math.random() * colors.length)];
            // ç¯æ³¡æœ¬ä½“ (å‘å…‰æè´¨)
            const bulbGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const bulbMat = new THREE.MeshBasicMaterial({ color: color });
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.set(x, yPos, z);
            
            // ç‚¹å…‰æº (ç…§äº®å‘¨å›´)
            const light = new THREE.PointLight(color, 0.5, 3);
            bulb.add(light); // å°†å…‰æºç»‘å®šåœ¨ç¯æ³¡ä¸Š
            treeGroup.add(bulb);

            // å­˜èµ·æ¥åšåŠ¨ç”»
            lights.push({ mesh: bulb, light: light, baseIntensity: 0.5 + Math.random()*0.5, speed: Math.random()*2+1 });
        }
    }

    // æ ‘é¡¶æ˜Ÿ
    function createStar() {
        const starGeo = new THREE.OctahedronGeometry(1, 0);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xffd700 }); // é‡‘è‰²å‘å…‰æè´¨
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.y = 22; // æ ‘é¡¶ä½ç½®
        treeGroup.add(star);
        
        // æ˜Ÿæ˜Ÿçš„å…‰è¾‰
        const starLight = new THREE.PointLight(0xffd700, 1.5, 20);
        star.add(starLight);

        // æ˜Ÿæ˜Ÿè‡ªè½¬åŠ¨ç”»
        gsap.to(star.rotation, { y: Math.PI*2, duration: 5, repeat: -1, ease: "linear" });
    }

    // åˆ›å»ºé›ªèŠ±
    function createSnow() {
        const snowGeo = new THREE.BufferGeometry();
        const snowCount = 1000;
        const pos = [];
        for(let i=0; i<snowCount; i++) {
            pos.push(Math.random()*100-50, Math.random()*100, Math.random()*100-50);
        }
        snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        // é›ªèŠ±æè´¨ï¼šç™½è‰²å°ç‚¹
        const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.4, transparent: true, opacity: 0.8 });
        const snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);
        // é›ªèŠ±ä¸‹è½åŠ¨ç”»
        gsap.to(snowSystem.rotation, { y: Math.PI/4, duration: 20, repeat:-1, ease:"linear" }); // ç¨å¾®å¸¦ç‚¹æ—‹è½¬
        function animateSnow() {
            const positions = snowSystem.geometry.attributes.position.array;
            for(let i=1; i<positions.length; i+=3) {
                positions[i] -= 0.1; // ä¸‹è½é€Ÿåº¦
                if(positions[i] < 0) positions[i] = 100; // å¾ªç¯
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            requestAnimationFrame(animateSnow);
        }
        animateSnow();
    }

    // åˆ›å»ºåœ°é¢
    function createFloor() {
        // ç™½è‰²é›ªåœ°
        const floorMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1.0 });
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
    }

    // --- æ ¸å¿ƒäº¤äº’ï¼šç‚¹å‡»ç…§ç‰‡ ---
    function onClick(event) {
        // å¦‚æœæ­£åœ¨è¿›è¡Œç›¸æœºåŠ¨ç”»ï¼Œå¿½ç•¥ç‚¹å‡»
        if (gsap.isTweening(camera.position) || gsap.isTweening(controls.target)) return;

        event.preventDefault();
        // è·å–ç‚¹å‡»åæ ‡ (å…¼å®¹ PC å’Œ æ‰‹æœº)
        let clientX, clientY;
        if (event.changedTouches) {
            clientX = event.changedTouches[0].clientX;
            clientY = event.changedTouches[0].clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }

        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        // æ£€æµ‹æ˜¯å¦ç‚¹å‡»åˆ°äº†ç…§ç‰‡å¡ç‰‡
        const intersects = raycaster.intersectObjects(photoCards);

        if (intersects.length > 0) {
            // --- ç‚¹å‡»äº†ç…§ç‰‡ï¼Œèšç„¦æŸ¥çœ‹ ---
            const card = intersects[0].object;
            if (focusedCard !== card) {
                focusOnCard(card);
            }
        } else {
            // --- ç‚¹å‡»äº†ç©ºç™½å¤„ï¼Œæ¢å¤å…¨æ™¯ ---
            if (focusedCard) {
                resetCamera();
            }
        }
    }

    // èšç„¦æŸ¥çœ‹ç…§ç‰‡çš„åŠ¨ç”»
    function focusOnCard(card) {
        focusedCard = card;
        controls.enabled = false; // èšç„¦æ—¶ç¦ç”¨æ‰‹åŠ¨æ§åˆ¶

        // è®¡ç®—ç›¸æœºç›®æ ‡ä½ç½®ï¼šå¡ç‰‡æ­£å‰æ–¹
        const targetPos = card.position.clone();
        // è·å–å¡ç‰‡çš„æœå‘å‘é‡
        const normal = new THREE.Vector3(0, 0, 1).applyQuaternion(card.quaternion);
        // ç›¸æœºä½ç½® = å¡ç‰‡ä½ç½® + æœå‘å‘é‡ * è·ç¦»
        const cameraTargetPos = targetPos.clone().add(normal.multiplyScalar(8)); 

        // ä½¿ç”¨ GSAP å¹³æ»‘ç§»åŠ¨ç›¸æœºå’Œè§†ç‚¹
        gsap.to(camera.position, {
            x: cameraTargetPos.x, y: cameraTargetPos.y, z: cameraTargetPos.z,
            duration: 1.5, ease: "power2.inOut"
        });
        gsap.to(controls.target, {
            x: targetPos.x, y: targetPos.y, z: targetPos.z,
            duration: 1.5, ease: "power2.inOut",
            onUpdate: () => controls.update() // å¿…é¡»æ›´æ–°æ§åˆ¶å™¨
        });
    }

    // æ¢å¤å…¨æ™¯æ¨¡å¼çš„åŠ¨ç”»
    function resetCamera() {
        focusedCard = null;
        gsap.to(camera.position, {
            x: defaultCameraPosition.x, y: defaultCameraPosition.y, z: defaultCameraPosition.z,
            duration: 1.5, ease: "power2.inOut",
            onComplete: () => { controls.enabled = true; } // åŠ¨ç”»ç»“æŸæ¢å¤æ§åˆ¶
        });
        gsap.to(controls.target, {
            x: 0, y: 8, z: 0, // çœ‹å›æ ‘ä¸­å¿ƒ
            duration: 1.5, ease: "power2.inOut",
            onUpdate: () => controls.update()
        });
    }

    // --- å›¾ç‰‡ä¸Šä¼ å¤„ç† ---
    document.getElementById('image-upload').addEventListener('change', function(e) {
        const files = e.target.files;
        if (!files.length) return;
        
        document.getElementById('loading-text').style.display = 'block';
        
        // æ¸…é™¤æ—§ç…§ç‰‡
        photoCards.forEach(card => treeGroup.remove(card));
        photoCards = [];

        let loadedCount = 0;
        const loader = new THREE.TextureLoader();

        for (let i = 0; i < files.length; i++) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                loader.load(ev.target.result, (texture) => {
                    // åˆ›å»ºæ‹ç«‹å¾—ç…§ç‰‡å¡ç‰‡ (å‰é¢æ˜¯ç…§ç‰‡ï¼Œåé¢æ˜¯çº¸æ¿)
                    // ä¿æŒç…§ç‰‡æ¯”ä¾‹
                    const aspect = texture.image.width / texture.image.height;
                    const cardWidth = 3;
                    const cardHeight = cardWidth / aspect;

                    const cardGeo = new THREE.BoxGeometry(cardWidth, cardHeight, 0.05);
                    // æè´¨æ•°ç»„ï¼šå‰ã€åã€ä¸Šã€ä¸‹ã€å·¦ã€å³
                    const materials = [
                        new THREE.MeshStandardMaterial({ color: 0xffffff }), // ä¾§è¾¹
                        new THREE.MeshStandardMaterial({ color: 0xffffff }), // ä¾§è¾¹
                        new THREE.MeshStandardMaterial({ color: 0xffffff }), // ä¾§è¾¹
                        new THREE.MeshStandardMaterial({ color: 0xffffff }), // ä¾§è¾¹
                        new THREE.MeshStandardMaterial({ map: texture }),    // æ­£é¢ (ç…§ç‰‡)
                        new THREE.MeshStandardMaterial({ color: 0xeeeeee })  // èƒŒé¢ (çº¸æ¿)
                    ];
                    const card = new THREE.Mesh(cardGeo, materials);

                    // éšæœºæŒ‚è½½ä½ç½®
                    const angle = Math.random() * Math.PI * 2;
                    const height = 6 + Math.random() * 12; // é«˜åº¦èŒƒå›´
                    const radius = (18 - height) * 0.5 + Math.random(); // æ ¹æ®é«˜åº¦è®¡ç®—åŠå¾„ï¼Œè´´è¿‘æ ‘æ
                    card.position.set(Math.cos(angle) * radius, height, Math.sin(angle) * radius);
                    
                    // éšæœºæ—‹è½¬ï¼Œçœ‹èµ·æ¥åƒæ˜¯æŒ‚ç€çš„
                    card.rotation.x = (Math.random() - 0.5) * 0.5;
                    card.rotation.y = angle + Math.PI/2; // é¢å‘å¤–ä¾§
                    card.rotation.z = (Math.random() - 0.5) * 0.5;

                    card.castShadow = true;
                    treeGroup.add(card);
                    photoCards.push(card);

                    loadedCount++;
                    if (loadedCount === files.length) {
                        document.getElementById('loading-text').style.display = 'none';
                        // å…³é—­è‡ªåŠ¨æ—‹è½¬ï¼Œæ–¹ä¾¿æŸ¥çœ‹
                        controls.autoRotate = false;
                        alert(`æˆåŠŸæŒ‚ä¸Šäº† ${loadedCount} å¼ ç…§ç‰‡ï¼\nç‚¹å‡»ç…§ç‰‡å¯ä»¥æ”¾å¤§æŸ¥çœ‹å“¦~`);
                    }
                });
            };
            reader.readAsDataURL(files[i]);
        }
    });

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        // å½©ç¯é—ªçƒåŠ¨ç”»
        const time = Date.now() * 0.001;
        lights.forEach(l => {
            l.light.intensity = l.baseIntensity + Math.sin(time * l.speed) * 0.3;
        });

        renderer.render(scene, camera);
    }

</script>
</body>
</html>