<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>åœ£è¯æ ‘ä¸“å±ç›¸å†Œ</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; }
        /* èƒŒæ™¯ï¼šåŠ äº†ä¸€ç‚¹ç‚¹ç´«è‰²çš„æ¢¦å¹»æ¸å˜ */
        #canvas-container { width: 100%; height: 100%; background: linear-gradient(to bottom, #050510, #1a0b2e); }
        #ui-controls {
            position: absolute; bottom: 30px; width: 100%; text-align: center; pointer-events: none; z-index: 100;
        }
        .btn {
            background: linear-gradient(to bottom, #e60000, #b30000);
            border: 2px solid #ffcc00; color: #fff; padding: 12px 30px; border-radius: 50px;
            font-size: 16px; font-weight: bold; cursor: pointer; pointer-events: auto;
            box-shadow: 0 4px 15px rgba(255, 0, 0, 0.4); text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.95); }
        /* æ–°å¢ï¼šé™åˆ¶æç¤ºæ–‡æ¡ˆ */
        .note {
            color: #ffd700; font-size: 12px; margin-bottom: 8px; text-shadow: 0 0 5px #000;
            background: rgba(0,0,0,0.3); display: inline-block; padding: 4px 10px; border-radius: 10px;
        }
        #image-upload { display: none; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://registry.npmmirror.com/three/0.160.0/files/build/three.module.js",
            "three/addons/": "https://registry.npmmirror.com/three/0.160.0/files/examples/jsm/",
            "gsap": "https://registry.npmmirror.com/gsap/3.12.5/files/index.js"
        }
    }
    </script>
</head>
<body>

<div id="canvas-container"></div>
<div id="ui-controls">
    <div class="note">âœ¨ æœ€ä½³æ•ˆæœï¼šè¯·ä¸Šä¼  1-6 å¼ ç…§ç‰‡ âœ¨</div><br>
    <input type="file" id="image-upload" multiple accept="image/*">
    <button class="btn" onclick="document.getElementById('image-upload').click()">ğŸ ä¸Šä¼ ç…§ç‰‡ (Max 6)</button>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import gsap from 'gsap';

    let scene, camera, renderer, controls;
    let treeGroup, photoCards = [];
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let focusedCard = null;
    let ledLights = []; 
    let snowSystem;

    init();

    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x1a0b2e, 0.015); // é›¾æ°”é¢œè‰²ä¸èƒŒæ™¯å‘¼åº”

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 10, 32);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // è°ƒäº®å…¨å±€æ›å…‰ï¼Œè®©ç”»é¢æ›´é€šé€
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.3; 
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 5; controls.maxDistance = 60;
        controls.target.set(0, 8, 0);
        controls.autoRotate = true; controls.autoRotateSpeed = 0.5;
        controls.addEventListener('start', () => { controls.autoRotate = false; });

        // --- ç¯å…‰ç³»ç»Ÿ (æ›´äº®) ---
        const ambient = new THREE.AmbientLight(0xffffff, 0.5); // æé«˜ç¯å¢ƒå…‰
        scene.add(ambient);
        
        const mainLight = new THREE.DirectionalLight(0xffd700, 1.5);
        mainLight.position.set(15, 20, 20);
        mainLight.castShadow = true;
        scene.add(mainLight);

        // åº•éƒ¨æš–å…‰ï¼Œç…§äº®ç¤¼ç‰©åŒºåŸŸ
        const bottomLight = new THREE.PointLight(0xff6600, 2.0, 20);
        bottomLight.position.set(0, 2, 5);
        scene.add(bottomLight);

        treeGroup = new THREE.Group();
        scene.add(treeGroup);
        
        createClassicTree(); 
        createOrnaments(); // æ–°å¢ï¼šç²¾è‡´çš„è£…é¥°çƒ
        createGifts(); 
        createStar(); 
        createSnow(); 

        window.addEventListener('resize', onWindowResize);
        renderer.domElement.addEventListener('click', onClick);
        renderer.domElement.addEventListener('touchstart', onClick, { passive: false });
        
        animate();
    }

    // --- 1. ç»å…¸æ ‘å½¢ (ä¼˜åŒ–æè´¨è´¨æ„Ÿ) ---
    function createClassicTree() {
        // ç¨å¾®åŠ ä¸€ç‚¹åå…‰ï¼Œè®©æ ‘å¶ä¸é‚£ä¹ˆâ€œæ­»æ¿â€
        const leafMat = new THREE.MeshStandardMaterial({ 
            color: 0x0f550f, roughness: 0.6, metalness: 0.1, flatShading: true 
        });

        const layers = 16;
        for (let i = 0; i < layers; i++) {
            const progress = i / layers;
            const radius = 7.5 * (1 - progress) + 0.5;
            const y = i * 0.9 + 1.5;
            const height = 2.0;
            
            const geo = new THREE.ConeGeometry(radius, height, 16);
            const mesh = new THREE.Mesh(geo, leafMat);
            mesh.position.y = y;
            // éšæœºæ—‹è½¬
            mesh.rotation.y = Math.random() * Math.PI;
            // éšæœºå¾®è°ƒæ¯”ä¾‹ï¼Œå¢åŠ è‡ªç„¶æ„Ÿ
            const s = 1 + Math.random()*0.1;
            mesh.scale.set(s, 1, s);
            treeGroup.add(mesh);

            // è¾¹ç¼˜å½©ç¯
            addEdgeLights(y - height/2 + 0.1, radius, i);
        }

        const trunkGeo = new THREE.CylinderGeometry(1.2, 1.6, 4, 10);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4A2F1B });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = -0.5;
        treeGroup.add(trunk);
    }

    function addEdgeLights(y, radius, layerIndex) {
        const count = Math.floor(radius * 2.5) + 3;
        const colors = [0xff0000, 0xffd700, 0x00ff00, 0x00aaff];

        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2 + layerIndex;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;

            const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
            const bulbGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const bulbMat = new THREE.MeshBasicMaterial({ color: color }); // è‡ªå‘å…‰
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.set(x, y, z);
            treeGroup.add(bulb);
            
            ledLights.push({ mesh: bulb, baseColor: color, speed: 1.5 + Math.random()*2, offset: Math.random()*10 });
        }
    }

    // --- 2. æ–°å¢ï¼šè£…é¥°çƒ (Baubles) å¢åŠ ç²¾è‡´åº¦ ---
    function createOrnaments() {
        const ballColors = [0xff0000, 0xffd700, 0xc0c0c0]; // çº¢ã€é‡‘ã€é“¶
        // éšæœºæ’’ 50 ä¸ªè£…é¥°çƒåœ¨æ ‘ä¸Š
        for (let i = 0; i < 50; i++) {
            const y = 2.5 + Math.random() * 12; // é«˜åº¦èŒƒå›´
            // æ ¹æ®é«˜åº¦è®¡ç®—åŠå¾„ï¼Œç¨å¾®å¾€é‡Œç¼©ä¸€ç‚¹ï¼ŒåµŒåœ¨å¶å­é‡Œ
            const rTree = 7.5 * (1 - ((y-1.5)/14.4)) + 0.5;
            const r = rTree * (0.6 + Math.random() * 0.3); 
            
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;

            const size = 0.2 + Math.random() * 0.15;
            const color = ballColors[Math.floor(Math.random() * ballColors.length)];
            
            // é«˜åå…‰æè´¨ï¼Œåƒç»ç’ƒçƒ
            const mat = new THREE.MeshStandardMaterial({ 
                color: color, roughness: 0.1, metalness: 0.8 
            });
            const ball = new THREE.Mesh(new THREE.SphereGeometry(size, 16, 16), mat);
            ball.position.set(x, y, z);
            treeGroup.add(ball);
        }
    }

    // --- 3. ç¤¼ç‰©å † (æ›´äº®æ›´ç²¾è‡´) ---
    function createGifts() {
        const giftColors = [0xd60000, 0x006400, 0xffd700, 0x003399];
        for(let i=0; i<12; i++) {
            const s = 1.0 + Math.random() * 1.5;
            const giftGeo = new THREE.BoxGeometry(s, s, s);
            const color = giftColors[Math.floor(Math.random()*giftColors.length)];
            const giftMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.1 });
            const gift = new THREE.Mesh(giftGeo, giftMat);
            
            const angle = Math.random() * Math.PI * 2;
            const r = 4.0 + Math.random() * 5.0;
            gift.position.set(Math.cos(angle)*r, s/2 - 1.8, Math.sin(angle)*r);
            gift.rotation.y = Math.random();

            // ä¸å¸¦æ›´äº®
            const ribbonMat = new THREE.MeshStandardMaterial({color:0xffffff, metalness:0.3, roughness: 0.2});
            const ribbon = new THREE.Mesh(new THREE.BoxGeometry(s*1.02, s*0.1, s*1.02), ribbonMat);
            const ribbon2 = new THREE.Mesh(new THREE.BoxGeometry(s*0.1, s*0.1, s*1.02), ribbonMat); // é¡¶éƒ¨ç»“
            ribbon2.position.y = s/2;
            gift.add(ribbon);
            gift.add(ribbon2);

            treeGroup.add(gift);
        }
    }

    // --- 4. æ ‘é¡¶æ˜Ÿ ---
    function createStar() {
        const starGeo = new THREE.IcosahedronGeometry(0.9, 0);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.y = 16.5;
        treeGroup.add(star);
        // å…‰æ™•
        const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=64;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(32,32,0,32,32,32);
        gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)'); gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient; ctx.fillRect(0,0,64,64);
        const glowTex = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ map: glowTex, color: 0xffd700, transparent: true, blending: THREE.AdditiveBlending });
        const sprite = new THREE.Sprite(spriteMat); sprite.scale.set(10, 10, 1); star.add(sprite);
    }

    // --- 5. é›ªèŠ± (æ•°é‡é€‚ä¸­ï¼Œ400ç‰‡) ---
    function createSnow() {
        const geo = new THREE.BufferGeometry();
        const snowCount = 400;
        const pos = []; const rot = [];
        for(let i=0; i<snowCount; i++) {
            pos.push((Math.random()-0.5)*80, Math.random()*60, (Math.random()-0.5)*80);
            rot.push(Math.random() * Math.PI);
        }
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        geo.setAttribute('rotation', new THREE.Float32BufferAttribute(rot, 1));
        
        const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
        const ctx = canvas.getContext('2d');
        const g = ctx.createRadialGradient(16,16,0,16,16,16);
        g.addColorStop(0, 'rgba(255,255,255,0.9)');
        g.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = g; ctx.fillRect(0,0,32,32);
        const snowTex = new THREE.CanvasTexture(canvas);

        const mat = new THREE.PointsMaterial({ 
            map: snowTex, color: 0xffffff, size: 1.2,
            transparent: true, opacity: 0.8, 
            blending: THREE.AdditiveBlending, depthWrite: false 
        });
        snowSystem = new THREE.Points(geo, mat);
        scene.add(snowSystem);
    }

    // --- äº¤äº’ï¼šé™åˆ¶ä¸Šä¼  6 å¼  ---
    document.getElementById('image-upload').addEventListener('change', function(e) {
        let files = Array.from(e.target.files);
        if (!files.length) return;

        // ã€ä¼˜åŒ–ã€‘é™åˆ¶æ•°é‡é€»è¾‘
        if (files.length > 6) {
            alert("âš ï¸ ä¸ºäº†æœ€ä½³å±•ç¤ºæ•ˆæœï¼Œæœ€å¤šåªèƒ½æŒ‚ 6 å¼ ç…§ç‰‡å“¦ï¼\nå·²è‡ªåŠ¨ä¸ºæ‚¨é€‰å–å‰ 6 å¼ ã€‚");
            files = files.slice(0, 6);
        }
        
        photoCards.forEach(c => treeGroup.remove(c)); photoCards = [];
        let loaded = 0;
        const loader = new THREE.TextureLoader();

        files.forEach((file, index) => {
            const reader = new FileReader();
            reader.onload = (ev) => {
                loader.load(ev.target.result, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    const aspect = texture.image.width / texture.image.height;
                    const w = 3.2; const h = w / aspect; // ç…§ç‰‡å°ºå¯¸åŠ å¤§ä¸€ç‚¹
                    
                    // è‡ªå‘å…‰ç…§ç‰‡
                    const photoMat = new THREE.MeshBasicMaterial({ map: texture });
                    const photo = new THREE.Mesh(new THREE.PlaneGeometry(w, h), photoMat);
                    // é‡‘è‰²è¾¹æ¡†
                    const border = new THREE.Mesh(new THREE.BoxGeometry(w+0.2, h+0.2, 0.05), new THREE.MeshStandardMaterial({color: 0xffd700, metalness: 0.9, roughness: 0.2}));
                    border.position.z = -0.03; photo.add(border);
                    
                    const group = new THREE.Group(); group.add(photo);
                    
                    // ã€ä¼˜åŒ–ã€‘æŒ‚è½½ä½ç½®åˆ†é…ï¼šç¡®ä¿ 6 å¼ ç…§ç‰‡å‡åŒ€åˆ†å¸ƒ
                    // æŠŠæ ‘åˆ†ä¸ºä¸Šä¸­ä¸‹åŒºåŸŸï¼Œç¡®ä¿ç…§ç‰‡ä¸ä¼šå…¨æŒ¤åœ¨ä¸€èµ·
                    const total = files.length;
                    const stepAngle = (Math.PI * 2) / total;
                    const angle = stepAngle * index + Math.random()*0.5; // å‡åŒ€åˆ†å¸ƒåŠ ä¸€ç‚¹éšæœº
                    
                    // é«˜åº¦ï¼šå‡åŒ€åˆ†å¸ƒåœ¨æ ‘è…°åˆ°æ ‘é¡¶
                    // æ ‘é«˜å¤§æ¦‚åœ¨ 1.5 åˆ° 15 ä¹‹é—´
                    // è®©ç…§ç‰‡åˆ†å¸ƒåœ¨ y=4 åˆ° y=12 ä¹‹é—´ï¼Œè¿™æ˜¯æœ€ä½³è§‚èµåŒº
                    const y = 4 + (index / total) * 8 + Math.random(); 
                    
                    // åŠå¾„ï¼šæ ¹æ®é«˜åº¦è‡ªåŠ¨è´´åˆæ ‘é¢ï¼Œå†å¾€å¤–æµ®ä¸€ç‚¹ç‚¹
                    const rTree = 7.5 * (1 - ((y-1.5)/14.4)) + 0.5;
                    const r = rTree + 1.2; 
                    
                    group.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                    group.lookAt(0, y, 0); // å…ˆé¢å‘ä¸­å¿ƒ
                    group.rotateY(Math.PI); // å†è½¬ 180 åº¦é¢å‘å¤–
                    group.rotateZ((Math.random()-0.5)*0.2); // å¾®å¾®æ­ªå¤´
                    
                    treeGroup.add(group); photoCards.push(group);
                    loaded++;
                    if(loaded === files.length) { 
                        controls.autoRotate = false; 
                        // ç¨å¾®å»¶è¿Ÿä¸€ä¸‹æç¤ºï¼Œä½“éªŒæ›´å¥½
                        setTimeout(()=> alert("ğŸ„ ç…§ç‰‡å·²æŒ‚å¥½ï¼\nç‚¹å‡»ç…§ç‰‡è¯•è¯•çœ‹ï¼Œç°åœ¨è§†è§’æ›´å®Œç¾äº†ï¼"), 500);
                    }
                });
            };
            reader.readAsDataURL(file);
        });
    });

    // --- äº¤äº’ï¼šå®Œç¾å¹³è§†èšç„¦ ---
    function onClick(event) {
        if (gsap.isTweening(camera.position)) return;
        event.preventDefault();
        const clientX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
        const clientY = event.changedTouches ? event.changedTouches[0].clientY : event.clientY;
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(photoCards, true);
        
        if (intersects.length > 0) {
            let target = intersects[0].object;
            while(target.parent !== treeGroup) target = target.parent;
            focusOnCard(target);
        } else if (focusedCard) {
            resetCamera();
        }
    }

    function focusOnCard(card) {
        focusedCard = card; controls.enabled = false;
        
        // è·å–ç…§ç‰‡çš„ä¸–ç•Œåæ ‡
        const targetPos = new THREE.Vector3(); 
        card.children[0].getWorldPosition(targetPos); 
        
        // ã€å…³é”®ä¿®æ­£ã€‘è®¡ç®—ç›¸æœºä½ç½®
        // ä¸å†ç®€å•åœ°æ²¿ç€æ³•çº¿å»¶ä¼¸ï¼ˆé‚£ä¼šå¯¼è‡´ä»°è§†/ä¿¯è§†ï¼‰
        // è€Œæ˜¯è®¡ç®—ä¸€ä¸ªä¸ç…§ç‰‡ "åŒé«˜åº¦" çš„ä½ç½®
        
        // è®¡ç®—ç…§ç‰‡ç›¸å¯¹äºæ ‘ä¸­å¿ƒçš„æ°´å¹³æ–¹å‘
        const dir = new THREE.Vector3(targetPos.x, 0, targetPos.z).normalize();
        
        // ç›¸æœºè·ç¦»ï¼šç¦»æ ‘ä¸­å¿ƒ 13 ä¸ªå•ä½ï¼ˆæ ¹æ®æ ‘çš„å¤§å°è°ƒæ•´ï¼‰
        const dist = 13;
        
        // æ–°çš„ç›¸æœºä½ç½®ï¼š
        // x, z: æ²¿ç€ç…§ç‰‡æ–¹å‘å¾€å¤–æ‹‰
        // y: ä¸ç…§ç‰‡é«˜åº¦ä¸€è‡´ (targetPos.y)ï¼Œç”šè‡³ç¨å¾®é«˜ä¸€ç‚¹ç‚¹(0.5)ä»¥ä¾¿ä¿¯è§†ä¸€ç‚¹ç‚¹ï¼Œæ›´è‡ªç„¶
        const camPos = new THREE.Vector3(
            dir.x * dist,
            targetPos.y + 0.5, // è§†çº¿ä¸ç…§ç‰‡åŸºæœ¬æŒå¹³
            dir.z * dist
        );

        // åŠ¨ç”»è¿‡æ¸¡
        gsap.to(camera.position, {
            x: camPos.x, y: camPos.y, z: camPos.z, 
            duration: 1.2, ease: "power2.out"
        });
        
        // æ§åˆ¶å™¨ä¸­å¿ƒä¹Ÿå¯¹å‡†ç…§ç‰‡
        gsap.to(controls.target, {
            x: targetPos.x, y: targetPos.y, z: targetPos.z, 
            duration: 1.2, ease: "power2.out", 
            onUpdate: () => controls.update()
        });
    }

    function resetCamera() {
        focusedCard = null;
        // é€€å›åˆ°å…¨æ™¯è§†è§’
        gsap.to(camera.position, {x: 0, y: 10, z: 32, duration: 1.2, ease: "power2.inOut", onComplete: () => controls.enabled = true});
        gsap.to(controls.target, {x: 0, y: 8, z: 0, duration: 1.2, ease: "power2.inOut", onUpdate: () => controls.update()});
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        const time = Date.now() * 0.005;
        
        // å½©ç¯é—ªçƒ
        ledLights.forEach(l => {
            const intensity = (Math.sin(time * l.speed + l.offset) + 1) / 2;
            l.mesh.material.color.lerpColors(new THREE.Color(0x111111), l.baseColor, intensity * 0.8 + 0.2);
        });

        // é›ªèŠ±é£˜è½
        if (snowSystem) {
            const positions = snowSystem.geometry.attributes.position.array;
            for(let i=1; i<positions.length; i+=3) {
                positions[i] -= 0.1; if(positions[i] < -10) positions[i] = 60; 
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            snowSystem.rotation.y += 0.001;
        }
        renderer.render(scene, camera);
    }
</script>
</body>
</html>