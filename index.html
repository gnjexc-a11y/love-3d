<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>è±ªååœ£è¯æ ‘ç›¸å†Œ</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; }
        /* èƒŒæ™¯å¾®è°ƒï¼šæ›´æ·±é‚ƒçš„å¹³å®‰å¤œ */
        #canvas-container { width: 100%; height: 100%; background: linear-gradient(to bottom, #020014, #0a1a3a); }
        #ui-controls {
            position: absolute; bottom: 40px; width: 100%; text-align: center; pointer-events: none; z-index: 100;
        }
        .btn {
            /* æŒ‰é’®å‡çº§ä¸ºçº¢é‡‘é…è‰² */
            background: linear-gradient(to bottom, #d60000, #900000);
            border: 3px solid #ffd700; color: #ffd700; padding: 12px 35px; border-radius: 50px;
            font-size: 18px; font-weight: bold; cursor: pointer; pointer-events: auto;
            box-shadow: 0 0 25px rgba(214, 0, 0, 0.6), inset 0 0 10px rgba(255, 215, 0, 0.3); letter-spacing: 2px; text-shadow: 1px 1px 2px #000;
        }
        #image-upload { display: none; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://registry.npmmirror.com/three/0.160.0/files/build/three.module.js",
            "three/addons/": "https://registry.npmmirror.com/three/0.160.0/files/examples/jsm/",
            "gsap": "https://registry.npmmirror.com/gsap/3.12.5/files/index.js"
        }
    }
    </script>
</head>
<body>

<div id="canvas-container"></div>
<div id="ui-controls">
    <input type="file" id="image-upload" multiple accept="image/*">
    <button class="btn" onclick="document.getElementById('image-upload').click()">ğŸ„ ä¸Šä¼ ç…§ç‰‡å¸ƒç½®åœ£è¯æ ‘</button>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
    import gsap from 'gsap';

    let scene, camera, renderer, controls;
    let treeGroup, photoCards = [];
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let focusedCard = null;
    let ledLights = []; // å­˜å‚¨ç¯å¸¦ä¸Šçš„å°ç¯ç 
    let snowSystem;

    init();

    function init() {
        scene = new THREE.Scene();
        // æµ“é›¾ï¼Œå¢åŠ ç¥ç§˜æ„Ÿå’Œæ™¯æ·±
        scene.fog = new THREE.FogExp2(0x0a1a3a, 0.02);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 12, 32); // åˆå§‹è§†è§’

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // å…¼é¡¾æ€§èƒ½å’Œæ¸…æ™°åº¦
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 5; controls.maxDistance = 60;
        controls.target.set(0, 8, 0);
        controls.autoRotate = true; controls.autoRotateSpeed = 0.5;
        controls.addEventListener('start', () => { controls.autoRotate = false; });

        // --- ç¯å…‰æ°›å›´ ---
        const ambient = new THREE.AmbientLight(0xccccff, 0.4);
        scene.add(ambient);
        const mainLight = new THREE.DirectionalLight(0xffd700, 1.0);
        mainLight.position.set(15, 25, 20);
        scene.add(mainLight);
        // åº•éƒ¨å¢åŠ æš–å…‰ï¼Œç…§äº®ç¤¼ç‰©
        const bottomLight = new THREE.PointLight(0xffaa55, 1.5, 30);
        bottomLight.position.set(0, 2, 0);
        scene.add(bottomLight);

        treeGroup = new THREE.Group();
        scene.add(treeGroup);
        
        createDeluxeTree(); // åˆ›å»ºè±ªåæ ‘
        createSpiralLights(); // åˆ›å»ºç¯å¸¦
        createGifts(); // åˆ›å»ºç¤¼ç‰©å †
        createStar(); 
        createReliableSnow(); // åˆ›å»ºå¯é çš„é›ªèŠ±

        window.addEventListener('resize', onWindowResize);
        renderer.domElement.addEventListener('click', onClick);
        renderer.domElement.addEventListener('touchstart', onClick, { passive: false });
        
        animate();
    }

    // --- 1. è±ªåç‰ˆåœ£è¯æ ‘ (å¯†é›†å †å ï¼Œæ‹’ç»ç®€é™‹) ---
    function createDeluxeTree() {
        // æ ‘å¶æè´¨ï¼šæ·±å¢¨ç»¿ï¼Œä½åå…‰ï¼Œæ¨¡æ‹Ÿé’ˆå¶
        const leafMat = new THREE.MeshStandardMaterial({ 
            color: 0x0A4F0A, roughness: 0.9, metalness: 0.0, flatShading: true 
        });

        // ä½¿ç”¨ BufferGeometryUtils åˆå¹¶å‡ ä½•ä½“ï¼Œæå‡æ€§èƒ½
        let geometries = [];
        // 80å±‚å¯†é›†å †å ï¼Œæ¨¡æ‹Ÿæ¯›èŒ¸èŒ¸çš„è´¨æ„Ÿ
        const layers = 80; 
        for (let i = 0; i < layers; i++) {
            const progress = i / layers; // 0åº•éƒ¨ -> 1é¡¶éƒ¨
            // åŠå¾„æ›²çº¿ï¼šåº•éƒ¨å®½ï¼Œä¸­é—´èƒ–ï¼Œé¡¶éƒ¨å°–
            const radius = 8 * Math.pow(1 - progress, 1.2) + 0.2;
            const y = i * 0.25 + 1.5; // é«˜åº¦æ›´å¯†
            const height = 1.5 * (1 - progress * 0.5) + 0.5; // é¡¶éƒ¨å¶ç‰‡å˜å°
            
            const geo = new THREE.ConeGeometry(radius, height, 16);
            geo.translate(0, y, 0); // ç§»åŠ¨ä½ç½®
            geo.rotateY(Math.random() * Math.PI * 2); // éšæœºæ—‹è½¬
            // éšæœºè½»å¾®å€¾æ–œï¼Œå¢åŠ è‡ªç„¶æ„Ÿ
            geo.rotateX((Math.random()-0.5)*0.1);
            geo.rotateZ((Math.random()-0.5)*0.1);
            geo.scale(1, 1 + Math.random()*0.2, 1); // é«˜åº¦éšæœºæ‹‰ä¼¸

            geometries.push(geo);
        }
        // åˆå¹¶æ‰€æœ‰æ ‘å¶ä¸ºä¸€ä¸ª Mesh
        const mergedGeo = BufferGeometryUtils.mergeGeometries(geometries);
        const treeMesh = new THREE.Mesh(mergedGeo, leafMat);
        treeGroup.add(treeMesh);

        // æ ‘å¹²
        const trunkGeo = new THREE.CylinderGeometry(1.2, 1.8, 5, 12);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4A2F1B, roughness: 1.0 });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = -1;
        treeGroup.add(trunk);
    }

    // --- 2. èºæ—‹ç¯å¸¦ (è±ªåæ„Ÿå…³é”®) ---
    function createSpiralLights() {
        // ç”Ÿæˆèºæ—‹æ›²çº¿è·¯å¾„
        const points = [];
        const turns = 6; // ç¼ ç»•åœˆæ•°
        const height = 20;
        const radiusBase = 8;
        for (let i = 0; i <= 100; i++) {
            const t = i / 100;
            const angle = t * createSpiralLights * Math.PI * turns;
            const r = radiusBase * (1 - t) + 0.5; // åŠå¾„éšé«˜åº¦å‡å°
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            const y = t * height + 1.5;
            points.push(new THREE.Vector3(x, y, z));
        }
        const curve = new THREE.CatmullRomCurve3(points);

        // åœ¨è·¯å¾„ä¸Šæ”¾ç½® LED ç¯ç 
        const ledCount = 300;
        const colors = [0xff0000, 0xffd700, 0x00ff00, 0x00aaff, 0xff3399];
        const ledGeo = new THREE.SphereGeometry(0.08, 8, 8); // å¾®å°çš„ç¯ç 

        for(let i=0; i<ledCount; i++) {
            const t = i / ledCount;
            const point = curve.getPoint(t);
            const color = colors[Math.floor(Math.random() * colors.length)];
            // è‡ªå‘å…‰æè´¨
            const ledMat = new THREE.MeshBasicMaterial({ color: color });
            const led = new THREE.Mesh(ledGeo, ledMat);
            led.position.copy(point);
            // ç¨å¾®éšæœºåç§»ä¸€ç‚¹ï¼Œä¸æ­»æ¿
            led.position.x += (Math.random()-0.5)*0.3;
            led.position.z += (Math.random()-0.5)*0.3;
            treeGroup.add(led);
            // å­˜å…¥æ•°ç»„åšé—ªçƒåŠ¨ç”»ï¼Œ speed æ˜¯é—ªçƒé€Ÿåº¦ï¼Œ offset æ˜¯ç›¸ä½å·®
            ledLights.push({ mesh: led, baseColor: new THREE.Color(color), speed: 2+Math.random()*3, offset: Math.random()*Math.PI*2 });
        }
    }

    // --- 3. æ ‘ä¸‹ç¤¼ç‰©å † (ä¸°å¯Œç»†èŠ‚) ---
    function createGifts() {
        const giftColors = [0xd60000, 0x008000, 0xffd700, 0x003399, 0xffffff];
        for(let i=0; i<12; i++) {
            // éšæœºå¤§å°
            const s = 1.5 + Math.random() * 1.5;
            const giftGeo = new THREE.BoxGeometry(s, s, s);
            const color = giftColors[Math.floor(Math.random()*giftColors.length)];
            const giftMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5 });
            const gift = new THREE.Mesh(giftGeo, giftMat);
            
            // éšæœºä½ç½®å›´ç»•æ ‘æ ¹
            const angle = Math.random() * Math.PI * 2;
            const r = 4 + Math.random() * 5;
            gift.position.set(Math.cos(angle)*r, s/2 - 2.5, Math.sin(angle)*r);
            gift.rotation.set(0, Math.random()*Math.PI, 0);

            // æ·»åŠ ä¸å¸¦ (åå­—äº¤å‰)
            const ribbonMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness:0.5, roughness:0.2 });
            const ribbon1 = new THREE.Mesh(new THREE.PlaneGeometry(s*1.02, s*0.2), ribbonMat);
            ribbon1.position.z = s/2 + 0.01;
            gift.add(ribbon1);
            
            const ribbon2 = new THREE.Mesh(new THREE.PlaneGeometry(s*1.02, s*0.2), ribbonMat);
            ribbon2.rotation.y = Math.PI/2;
            ribbon2.position.x = s/2 + 0.01;
            gift.add(ribbon2);
            
            // é¡¶éƒ¨è´è¶ç»“ (ç®€å•æ¨¡æ‹Ÿ)
            const bow = new THREE.Mesh(new THREE.BoxGeometry(s*0.4, s*0.2, s*0.4), ribbonMat);
            bow.position.y = s/2 + 0.1;
            gift.add(bow);

            treeGroup.add(gift);
        }
    }

    // --- 4. ä¿®å¤çš„é›ªèŠ±ç³»ç»Ÿ (100% å¯è§) ---
    function createReliableSnow() {
        const geo = new THREE.BufferGeometry();
        const pos = []; const rot = [];
        for(let i=0; i<2000; i++) { // å¢åŠ é›ªèŠ±æ•°é‡
            pos.push((Math.random()-0.5)*100, Math.random()*80, (Math.random()-0.5)*100);
            rot.push(Math.random() * Math.PI);
        }
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        geo.setAttribute('rotation', new THREE.Float32BufferAttribute(rot, 1));
        
        // ç”¨ä»£ç ç”Ÿæˆé›ªèŠ±çº¹ç†ï¼Œä¸ä¾èµ–å¤–éƒ¨å›¾ç‰‡
        const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
        const ctx = canvas.getContext('2d');
        const g = ctx.createRadialGradient(16,16,0,16,16,16);
        g.addColorStop(0, 'rgba(255,255,255,1)');
        g.addColorStop(0.5, 'rgba(255,255,255,0.8)');
        g.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = g; ctx.fillRect(0,0,32,32);
        const snowTex = new THREE.CanvasTexture(canvas);

        const mat = new THREE.PointsMaterial({ 
            map: snowTex, color: 0xffffff, size: 1.5, // åŠ å¤§é›ªèŠ±å°ºå¯¸
            transparent: true, opacity: 0.8, 
            blending: THREE.AdditiveBlending, depthWrite: false 
        });
        snowSystem = new THREE.Points(geo, mat);
        scene.add(snowSystem);
    }

    // æ ‘é¡¶æ˜Ÿ (ä¿æŒä¸å˜ï¼Œè¿™ä¸ªæ•ˆæœä¸é”™)
    function createStar() {
        const starGeo = new THREE.IcosahedronGeometry(1.0, 0);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.y = 22;
        treeGroup.add(star);
        const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=64;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(32,32,0,32,32,32);
        gradient.addColorStop(0, 'rgba(255, 215, 0, 1)'); gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient; ctx.fillRect(0,0,64,64);
        const glowTex = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ map: glowTex, color: 0xffd700, transparent: true, blending: THREE.AdditiveBlending, opacity: 1.0 });
        const sprite = new THREE.Sprite(spriteMat); sprite.scale.set(10, 10, 1); star.add(sprite);
    }

    // --- ç…§ç‰‡ä¸Šä¼  (ä¿æŒ V5.0 çš„ä¼˜ç§€æ•ˆæœ) ---
    document.getElementById('image-upload').addEventListener('change', function(e) {
        const files = e.target.files;
        if (!files.length) return;
        photoCards.forEach(c => treeGroup.remove(c)); photoCards = [];
        const maxFiles = Math.min(files.length, 30);
        let loaded = 0;
        const loader = new THREE.TextureLoader();
        for (let i = 0; i < maxFiles; i++) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                loader.load(ev.target.result, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    const aspect = texture.image.width / texture.image.height;
                    const w = 3.0; const h = w / aspect; // ç…§ç‰‡ç¨å¾®å¤§ä¸€ç‚¹
                    const photoMat = new THREE.MeshBasicMaterial({ map: texture });
                    const photo = new THREE.Mesh(new THREE.PlaneGeometry(w, h), photoMat);
                    const border = new THREE.Mesh(new THREE.BoxGeometry(w+0.2, h+0.2, 0.05), new THREE.MeshStandardMaterial({color: 0xffd700, roughness: 0.3, metalness: 0.9}));
                    border.position.z = -0.03;
                    photo.add(border);
                    const group = new THREE.Group(); group.add(photo);
                    
                    // æŒ‚è½½é€»è¾‘ä¼˜åŒ–ï¼šæ›´å‡åŒ€åˆ†å¸ƒåœ¨æ ‘è¡¨é¢
                    const angle = Math.random() * Math.PI * 2;
                    const y = 3 + Math.random() * 16; // é«˜åº¦èŒƒå›´
                    const r = 8 * Math.pow(1 - (y/21), 1.2) + 1.5; // è´´åˆæ–°æ ‘å½¢çš„åŠå¾„å…¬å¼
                    
                    group.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                    group.lookAt(group.position.x*2, y, group.position.z*2);
                    group.rotateZ((Math.random()-0.5)*0.4);
                    treeGroup.add(group); photoCards.push(group);
                    loaded++;
                    if(loaded === maxFiles) { controls.autoRotate = false; alert("ğŸ„ è±ªååœ£è¯æ ‘å¸ƒç½®å®Œæˆï¼ç‚¹å‡»ç…§ç‰‡æŸ¥çœ‹ç»†èŠ‚ï¼"); }
                });
            };
            reader.readAsDataURL(files[i]);
        }
    });

    // --- ç‚¹å‡»äº¤äº’ (ä¿æŒ V5.0 çš„ä¼˜ç§€è§†è§’) ---
    function onClick(event) {
        if (gsap.isTweening(camera.position)) return;
        event.preventDefault();
        const clientX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
        const clientY = event.changedTouches ? event.changedTouches[0].clientY : event.clientY;
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(photoCards, true);
        if (intersects.length > 0) {
            let target = intersects[0].object;
            while(target.parent !== treeGroup) target = target.parent;
            focusOnCard(target);
        } else if (focusedCard) {
            resetCamera();
        }
    }
    function focusOnCard(card) {
        focusedCard = card; controls.enabled = false;
        const targetPos = new THREE.Vector3(); card.children[0].getWorldPosition(targetPos); 
        const offset = targetPos.clone().normalize().multiplyScalar(10); // è·ç¦»10
        const camPos = targetPos.clone().add(offset);
        gsap.to(camera.position, {x: camPos.x, y: camPos.y, z: camPos.z, duration: 1.2, ease: "power2.out"});
        gsap.to(controls.target, {x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: 1.2, ease: "power2.out", onUpdate: () => controls.update()});
    }
    function resetCamera() {
        focusedCard = null;
        gsap.to(camera.position, {x: 0, y: 12, z: 32, duration: 1.2, ease: "power2.inOut", onComplete: () => controls.enabled = true});
        gsap.to(controls.target, {x: 0, y: 8, z: 0, duration: 1.2, ease: "power2.inOut", onUpdate: () => controls.update()});
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        const time = Date.now() * 0.005;
        
        // LED ç¯å¸¦é—ªçƒåŠ¨ç”»
        ledLights.forEach(l => {
            // åˆ©ç”¨ sin å‡½æ•°å®ç°å‘¼å¸é—ªçƒæ•ˆæœ
            const intensity = (Math.sin(time * l.speed + l.offset) + 1) / 2; // 0 åˆ° 1 ä¹‹é—´
            // é¢œè‰²åœ¨åŸè‰²å’Œå˜æš—ä¹‹é—´åˆ‡æ¢
            l.mesh.material.color.lerpColors(new THREE.Color(0x000000), l.baseColor, intensity * 0.8 + 0.2);
        });

        // é›ªèŠ±åŠ¨ç”»
        if (snowSystem) {
            const positions = snowSystem.geometry.attributes.position.array;
            for(let i=1; i<positions.length; i+=3) {
                positions[i] -= 0.15; 
                if(positions[i] < -10) positions[i] = 70; 
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            snowSystem.rotation.y += 0.001;
        }
        renderer.render(scene, camera);
    }
</script>
</body>
</html>